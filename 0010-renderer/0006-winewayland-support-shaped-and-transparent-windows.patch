From 48e47d06fd6b7daf90c0b664ab7967e98512e5d6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 21:22:18 +0200
Subject: [PATCH 1/3] winewayland: Post WM_WAYLAND_CONFIGURE outside of the
 surface lock.

---
 dlls/winewayland.drv/wayland_surface.c | 7 ++++---
 1 file changed, 4 insertions(+), 3 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 39c3976cdfd..5e7b04842f6 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -38,7 +38,7 @@ static void xdg_surface_handle_configure(void *data, struct xdg_surface *xdg_sur
                                          uint32_t serial)
 {
     struct wayland_surface *surface;
-    BOOL initial_configure = FALSE;
+    BOOL should_post = FALSE, initial_configure = FALSE;
     HWND hwnd = data;
 
     TRACE("serial=%u\n", serial);
@@ -52,16 +52,17 @@ static void xdg_surface_handle_configure(void *data, struct xdg_surface *xdg_sur
         /* If we have a previously requested config, we have already sent a
          * WM_WAYLAND_CONFIGURE which hasn't been handled yet. In that case,
          * avoid sending another message to reduce message queue traffic. */
-        BOOL should_post = surface->requested.serial == 0;
+        should_post = surface->requested.serial == 0;
         initial_configure = surface->current.serial == 0;
         surface->pending.serial = serial;
         surface->requested = surface->pending;
         memset(&surface->pending, 0, sizeof(surface->pending));
-        if (should_post) NtUserPostMessage(hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
     }
 
     pthread_mutex_unlock(&surface->mutex);
 
+    if (should_post) NtUserPostMessage(hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
+
     /* Flush the window surface in case there is content that we weren't
      * able to flush before due to the lack of the initial configure. */
     if (initial_configure) wayland_window_flush(hwnd);
-- 
GitLab


# From be30ffb53e5955ee1c08535bd564b75d27f28060 Mon Sep 17 00:00:00 2001
# From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
# Date: Fri, 28 Jun 2024 20:23:44 +0200
# Subject: [PATCH 2/3] winewayland: Use WL_SHM_FORMAT_ARGB8888 format for window
#  surfaces.

# ---
#  dlls/winewayland.drv/window_surface.c | 6 ++++--
#  1 file changed, 4 insertions(+), 2 deletions(-)

# diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
# index e9eb74b17ca..3b354925a8e 100644
# --- a/dlls/winewayland.drv/window_surface.c
# +++ b/dlls/winewayland.drv/window_surface.c
# @@ -154,7 +154,7 @@ static struct wayland_shm_buffer *wayland_buffer_queue_get_free_buffer(struct wa
#          if (nbuffers < 3)
#          {
#              shm_buffer = wayland_shm_buffer_create(queue->width, queue->height,
# -                                                   WL_SHM_FORMAT_XRGB8888);
# +                                                   WL_SHM_FORMAT_ARGB8888);
#              if (shm_buffer)
#              {
#                  /* Buffer events go to their own queue so that we can dispatch
# @@ -262,7 +262,7 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
#      {
#          const char *src;
#          char *dst;
# -        int y, width_bytes, height;
# +        int x, y, width_bytes, height;
#          RECT rc;
 
#          TRACE("rect %s\n", wine_dbgstr_rect(rgn_rect));
# @@ -279,12 +279,14 @@ static void copy_pixel_region(const char *src_pixels, RECT *src_rect,
#          if (width_bytes == src_stride && width_bytes == dst_stride)
#          {
#              memcpy(dst, src, height * width_bytes);
# +            for (x = 3; x < height * width_bytes; x += bpp) dst[x] = 0xff;
#              continue;
#          }
 
#          for (y = 0; y < height; y++)
#          {
#              memcpy(dst, src, width_bytes);
# +            for (x = 3; x < width_bytes; x += bpp) dst[x] = 0xff;
#              src += src_stride;
#              dst += dst_stride;
#          }
# -- 
# GitLab


From da62d425afbd1e50463280dd87c427048d8d2a5e Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 28 Jun 2024 20:23:44 +0200
Subject: [PATCH 3/3] winewayland: Implement window surface shape and color
 keying.

---
 dlls/winewayland.drv/window_surface.c | 29 +++++++++++++++++++++++++++
 1 file changed, 29 insertions(+)

diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 3b354925a8e..961ba511c7a 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -317,6 +317,34 @@ static void wayland_shm_buffer_copy(struct wayland_shm_buffer *src,
     copy_pixel_region(src->map_data, &src_rect, dst->map_data, &dst_rect, region);
 }
 
+/**********************************************************************
+ *          wayland_shm_buffer_copy_data
+ */
+static void wayland_shm_buffer_copy_shape(struct wayland_shm_buffer *buffer, const RECT *dirty,
+                                          const BITMAPINFO *shape_info, const void *shape_bits)
+{
+    RECT dst_rect = {0, 0, buffer->width, buffer->height};
+    UINT32 *color, shape_stride, color_stride, x, y;
+    const BYTE *shape;
+    RECT rect;
+
+    shape_stride = shape_info->bmiHeader.biSizeImage / abs(shape_info->bmiHeader.biHeight);
+    color_stride = dst_rect.right - dst_rect.left;
+
+    if (!intersect_rect(&rect, &dst_rect, dirty)) return;
+
+    color = (UINT32 *)buffer->map_data + rect.top * color_stride;
+    shape = (const BYTE *)shape_bits + rect.top * shape_stride;
+
+    for (y = rect.top; y < rect.bottom; y++, color += color_stride, shape += shape_stride)
+    {
+        for (x = rect.left; x < rect.right; x++)
+        {
+            if (!(shape[x / 8] & (1 << (7 - (x & 7))))) color[x] = 0;
+        }
+    }
+}
+
 /***********************************************************************
  *           wayland_window_surface_flush
  */
@@ -387,6 +415,7 @@ static BOOL wayland_window_surface_flush(struct window_surface *window_surface,
     }
 
     wayland_shm_buffer_copy_data(shm_buffer, color_bits, &surface_rect, copy_from_window_region);
+    if (shape_bits) wayland_shm_buffer_copy_shape(shm_buffer, rect, shape_info, shape_bits);
 
     pthread_mutex_lock(&wws->wayland_surface->mutex);
     if (wayland_surface_reconfigure(wws->wayland_surface))
-- 
GitLab

