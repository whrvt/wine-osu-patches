diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 2de1a26f537..68c2a92271c 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1514,7 +1514,7 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
     /* Default GLX and WGL swap interval is 1, but in case of glXSwapIntervalSGI
      * there is no way to query it, so we have to store it here.
      */
-    gl->swap_interval = 1;
+    gl->swap_interval = 0;
     gl->refresh_swap_interval = TRUE;
     gl->format = format;
     gl->ref = 1;
@@ -1595,7 +1595,7 @@ static struct gl_drawable *create_gl_drawable( HWND hwnd, const struct wgl_pixel
     pthread_mutex_lock( &context_mutex );
     if (!XFindContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char **)&prev ))
     {
-        gl->swap_interval = prev->swap_interval;
+        gl->swap_interval = 0;
         release_gl_drawable( prev );
     }
     XSaveContext( gdi_display, (XID)hwnd, gl_hwnd_context, (char *)grab_gl_drawable(gl) );
@@ -4665,7 +4665,7 @@ static int X11DRV_wglGetSwapIntervalEXT(void)
     swap_interval = gl->swap_interval;
     release_gl_drawable(gl);
 
-    return swap_interval;
+    return 0;
 }
 
 /**
@@ -4697,10 +4697,10 @@ static BOOL X11DRV_wglSwapIntervalEXT(int interval)
     }
 
     pthread_mutex_lock( &context_mutex );
-    ret = set_swap_interval(gl->drawable, interval);
+    ret = set_swap_interval(gl->drawable, 0);
     gl->refresh_swap_interval = FALSE;
     if (ret)
-        gl->swap_interval = interval;
+        gl->swap_interval = 0;
     else
         RtlSetLastWin32Error(ERROR_DC_NOT_FOUND);
 
@@ -4926,7 +4926,7 @@ static BOOL glxdrv_wglSwapBuffers( HDC hdc )
     pthread_mutex_lock( &context_mutex );
     if (gl->refresh_swap_interval)
     {
-        set_swap_interval(gl->drawable, gl->swap_interval);
+        set_swap_interval(gl->drawable, 0);
         gl->refresh_swap_interval = FALSE;
     }
     pthread_mutex_unlock( &context_mutex );
