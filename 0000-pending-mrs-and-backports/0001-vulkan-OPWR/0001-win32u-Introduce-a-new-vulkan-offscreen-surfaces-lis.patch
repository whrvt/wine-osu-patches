From d79d1cbbea92d26dcd679be2da4828b887c783bb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 24 Apr 2024 11:12:31 +0200
Subject: [PATCH 01/10] win32u: Introduce a new vulkan offscreen surfaces list.

---
 dlls/win32u/vulkan.c | 28 ++++++++++++++++++++--------
 1 file changed, 20 insertions(+), 8 deletions(-)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 5b128afe3cb..91cfa237a61 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -45,6 +45,10 @@ static void *vulkan_handle;
 static const struct vulkan_driver_funcs *driver_funcs;
 static struct vulkan_funcs vulkan_funcs;
 
+/* list of surfaces attached to other processes / desktop windows */
+static struct list offscreen_surfaces = LIST_INIT(offscreen_surfaces);
+static pthread_mutex_t vulkan_mutex = PTHREAD_MUTEX_INITIALIZER;
+
 static void (*p_vkDestroySurfaceKHR)(VkInstance, VkSurfaceKHR, const VkAllocationCallbacks *);
 static VkResult (*p_vkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 static void *(*p_vkGetDeviceProcAddr)(VkDevice, const char *);
@@ -71,6 +75,7 @@ static inline VkSurfaceKHR surface_to_handle( struct surface *surface )
 static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin32SurfaceCreateInfoKHR *info,
                                                 const VkAllocationCallbacks *allocator, VkSurfaceKHR *handle )
 {
+    HWND toplevel = NtUserGetAncestor( info->hwnd, GA_ROOT );
     struct surface *surface;
     VkResult res;
     WND *win;
@@ -85,8 +90,12 @@ static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin
         return res;
     }
 
-    if (!(win = get_win_ptr( info->hwnd )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
-        list_init( &surface->entry );
+    if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
+    {
+        pthread_mutex_lock( &vulkan_mutex );
+        list_add_tail( &offscreen_surfaces, &surface->entry );
+        pthread_mutex_unlock( &vulkan_mutex );
+    }
     else
     {
         list_add_tail( &win->vulkan_surfaces, &surface->entry );
@@ -105,7 +114,10 @@ static void win32u_vkDestroySurfaceKHR( VkInstance instance, VkSurfaceKHR handle
     TRACE( "instance %p, handle 0x%s, allocator %p\n", instance, wine_dbgstr_longlong(handle), allocator );
     if (allocator) FIXME( "Support for allocation callbacks not implemented yet\n" );
 
+    pthread_mutex_lock( &vulkan_mutex );
     list_remove( &surface->entry );
+    pthread_mutex_unlock( &vulkan_mutex );
+
     p_vkDestroySurfaceKHR( instance, surface->host_surface, NULL /* allocator */ );
     driver_funcs->p_vulkan_surface_destroy( surface->hwnd, surface->driver_private );
     free( surface );
@@ -313,14 +325,14 @@ static void vulkan_init(void)
 
 void vulkan_detach_surfaces( struct list *surfaces )
 {
-    struct surface *surface, *next;
+    struct surface *surface;
 
-    LIST_FOR_EACH_ENTRY_SAFE( surface, next, surfaces, struct surface, entry )
-    {
+    LIST_FOR_EACH_ENTRY( surface, surfaces, struct surface, entry )
         driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
-        list_remove( &surface->entry );
-        list_init( &surface->entry );
-    }
+
+    pthread_mutex_lock( &vulkan_mutex );
+    list_move_tail( &offscreen_surfaces, surfaces );
+    pthread_mutex_unlock( &vulkan_mutex );
 }
 
 /***********************************************************************
-- 
2.45.1

