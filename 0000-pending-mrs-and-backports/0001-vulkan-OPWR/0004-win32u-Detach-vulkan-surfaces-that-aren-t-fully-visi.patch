From bc5764024932969016ccc8d84cb38254d257dd98 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 3 May 2024 10:35:31 +0200
Subject: [PATCH 04/10] win32u: Detach vulkan surfaces that aren't fully
 visible.

And attach them back when they are.
---
 dlls/win32u/ntuser_private.h |  1 +
 dlls/win32u/vulkan.c         | 54 ++++++++++++++++++++++++++++++++----
 dlls/win32u/window.c         |  4 ++-
 3 files changed, 53 insertions(+), 6 deletions(-)

diff --git a/dlls/win32u/ntuser_private.h b/dlls/win32u/ntuser_private.h
index 04396abca72..7662436a588 100644
--- a/dlls/win32u/ntuser_private.h
+++ b/dlls/win32u/ntuser_private.h
@@ -258,6 +258,7 @@ extern LRESULT system_tray_call( HWND hwnd, UINT msg, WPARAM wparam, LPARAM lpar
 /* vulkan.c */
 extern void vulkan_detach_surfaces( struct list *surfaces );
 extern void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent );
+extern void vulkan_set_region( HWND toplevel, HRGN region );
 
 /* window.c */
 HANDLE alloc_user_handle( struct user_object *ptr, unsigned int type );
diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index d739a46ab39..dc126726bc9 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -59,6 +59,7 @@ struct surface
     struct list entry;
     VkSurfaceKHR host_surface;
     void *driver_private;
+    BOOL is_detached;
     HWND hwnd;
 };
 
@@ -96,12 +97,17 @@ static VkResult win32u_vkCreateWin32SurfaceKHR( VkInstance instance, const VkWin
         list_add_tail( &offscreen_surfaces, &surface->entry );
         pthread_mutex_unlock( &vulkan_mutex );
         driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
+        surface->is_detached = TRUE;
     }
     else
     {
         list_add_tail( &win->vulkan_surfaces, &surface->entry );
         release_win_ptr( win );
-        if (toplevel != info->hwnd) driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
+        if (toplevel != info->hwnd)
+        {
+            driver_funcs->p_vulkan_surface_detach( info->hwnd, surface->driver_private );
+            surface->is_detached = TRUE;
+        }
     }
 
     surface->hwnd = info->hwnd;
@@ -342,7 +348,11 @@ void vulkan_detach_surfaces( struct list *surfaces )
     struct surface *surface;
 
     LIST_FOR_EACH_ENTRY( surface, surfaces, struct surface, entry )
+    {
+        if (surface->is_detached) continue;
         driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
+        surface->is_detached = TRUE;
+    }
 
     pthread_mutex_lock( &vulkan_mutex );
     list_move_tail( &offscreen_surfaces, surfaces );
@@ -351,7 +361,6 @@ void vulkan_detach_surfaces( struct list *surfaces )
 
 static void append_window_surfaces( HWND toplevel, struct list *surfaces )
 {
-    struct surface *surface;
     WND *win;
 
     if (!(win = get_win_ptr( toplevel )) || win == WND_DESKTOP || win == WND_OTHER_PROCESS)
@@ -364,9 +373,6 @@ static void append_window_surfaces( HWND toplevel, struct list *surfaces )
     {
         list_move_tail( &win->vulkan_surfaces, surfaces );
         release_win_ptr( win );
-
-        LIST_FOR_EACH_ENTRY( surface, surfaces, struct surface, entry )
-            driver_funcs->p_vulkan_surface_attach( surface->hwnd, surface->driver_private );
     }
 }
 
@@ -414,12 +420,50 @@ void vulkan_set_parent( HWND hwnd, HWND new_parent, HWND old_parent )
 
     enum_window_surfaces( old_toplevel, hwnd, &surfaces );
 
+    /* surfaces will be re-attached as needed from surface region updates */
     LIST_FOR_EACH_ENTRY( surface, &surfaces, struct surface, entry )
+    {
+        if (surface->is_detached) continue;
         driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
+        surface->is_detached = TRUE;
+    }
 
     append_window_surfaces( new_toplevel, &surfaces );
 }
 
+void vulkan_set_region( HWND toplevel, HRGN region )
+{
+    struct list surfaces = LIST_INIT(surfaces);
+    struct surface *surface;
+
+    enum_window_surfaces( toplevel, toplevel, &surfaces );
+
+    LIST_FOR_EACH_ENTRY( surface, &surfaces, struct surface, entry )
+    {
+        RECT client_rect;
+        BOOL is_clipped;
+
+        NtUserGetClientRect( surface->hwnd, &client_rect );
+        NtUserMapWindowPoints( surface->hwnd, toplevel, (POINT *)&client_rect, 2 );
+        is_clipped = NtGdiRectInRegion( region, &client_rect );
+
+        if (is_clipped && !surface->is_detached)
+        {
+            TRACE( "surface %p is now clipped\n", surface->hwnd );
+            driver_funcs->p_vulkan_surface_detach( surface->hwnd, surface->driver_private );
+            surface->is_detached = TRUE;
+        }
+        else if (!is_clipped && surface->is_detached)
+        {
+            TRACE( "surface %p is now unclipped\n", surface->hwnd );
+            driver_funcs->p_vulkan_surface_attach( surface->hwnd, surface->driver_private );
+            surface->is_detached = FALSE;
+        }
+    }
+
+    append_window_surfaces( toplevel, &surfaces );
+}
+
 /***********************************************************************
  *      __wine_get_vulkan_driver  (win32u.so)
  */
diff --git a/dlls/win32u/window.c b/dlls/win32u/window.c
index f630f107b00..4cef4b71757 100644
--- a/dlls/win32u/window.c
+++ b/dlls/win32u/window.c
@@ -1788,12 +1788,14 @@ static void update_surface_region( HWND hwnd )
         NtGdiOffsetRgn( region, -visible.left, -visible.top );
         if (shape) NtGdiCombineRgn( region, region, shape, RGN_AND );
         window_surface_set_clip( win->surface, region );
-        NtGdiDeleteObjectApp( region );
     }
 
 done:
     if (shape) NtGdiDeleteObjectApp( shape );
     release_win_ptr( win );
+
+    vulkan_set_region( hwnd, region );
+    if (region) NtGdiDeleteObjectApp( region );
 }
 
 /***********************************************************************
