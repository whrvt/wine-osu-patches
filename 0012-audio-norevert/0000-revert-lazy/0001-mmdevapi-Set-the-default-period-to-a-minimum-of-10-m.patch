From 86ac5f5638f90388d5f484aea1cb8e0b1c945e4c Mon Sep 17 00:00:00 2001
From: Davide Beatrici <git@davidebeatrici.dev>
Date: Fri, 14 Jun 2024 22:41:15 +0200
Subject: [PATCH 1/2] mmdevapi: Set the default period to a minimum of 10 ms.

---
 dlls/mmdevapi/client.c | 55 ++++++++++++++++++++----------------------
 1 file changed, 26 insertions(+), 29 deletions(-)

diff --git b/dlls/mmdevapi/client.c a/dlls/mmdevapi/client.c
index ed635bc..0b849e4 100644
--- b/dlls/mmdevapi/client.c
+++ a/dlls/mmdevapi/client.c
@@ -99,36 +99,25 @@ static inline struct audio_client *impl_from_IAudioStreamVolume(IAudioStreamVolu
     return CONTAINING_RECORD(iface, struct audio_client, IAudioStreamVolume_iface);
 }
 
-static HRESULT get_periods(struct audio_client *client,
-                           REFERENCE_TIME *def_period, REFERENCE_TIME *min_period)
-{
-    static const REFERENCE_TIME min_def_period = 100000; /* 10 ms */
-    struct get_device_period_params params;
-
-    params.device     = client->device_name;
-    params.flow       = client->dataflow;
-    params.def_period = def_period;
-    params.min_period = min_period;
-
-    wine_unix_call(get_device_period, &params);
-
-    if (def_period) *def_period = max(*def_period, min_def_period);
-
-    return params.result;
-}
-
-static HRESULT adjust_timing(struct audio_client *client,
+static HRESULT adjust_timing(struct audio_client *This,
                              REFERENCE_TIME *duration, REFERENCE_TIME *period,
                              const AUDCLNT_SHAREMODE mode, const DWORD flags,
                              const WAVEFORMATEX *fmt)
 {
+    struct get_device_period_params params;
     REFERENCE_TIME def_period, min_period;
-    HRESULT hr;
 
     TRACE("Requested duration %lu and period %lu\n", (ULONG)*duration, (ULONG)*period);
 
-    if (FAILED(hr = get_periods(client, &def_period, &min_period)))
-        return hr;
+    params.device     = This->device_name;
+    params.flow       = This->dataflow;
+    params.def_period = &def_period;
+    params.min_period = &min_period;
+
+    wine_unix_call(get_device_period, &params);
+
+    if (FAILED(params.result))
+        return params.result;
 
     TRACE("Device periods: %lu default and %lu minimum\n", (ULONG)def_period, (ULONG)min_period);
 
@@ -140,21 +129,21 @@ static HRESULT adjust_timing(struct audio_client *client,
         const WAVEFORMATEXTENSIBLE *fmtex = (WAVEFORMATEXTENSIBLE *)fmt;
         if (fmtex->Format.wFormatTag == WAVE_FORMAT_EXTENSIBLE &&
            (fmtex->dwChannelMask == 0 || fmtex->dwChannelMask & SPEAKER_RESERVED))
-            hr = AUDCLNT_E_UNSUPPORTED_FORMAT;
+            params.result = AUDCLNT_E_UNSUPPORTED_FORMAT;
         else {
             if (*period == 0)
                 *period = def_period;
             if (*period < min_period || *period > 5000000)
-                hr = AUDCLNT_E_INVALID_DEVICE_PERIOD;
+                params.result = AUDCLNT_E_INVALID_DEVICE_PERIOD;
             else if (*duration > 20000000) /* The smaller the period, the lower this limit. */
-                hr = AUDCLNT_E_BUFFER_SIZE_ERROR;
+                params.result = AUDCLNT_E_BUFFER_SIZE_ERROR;
             else if (flags & AUDCLNT_STREAMFLAGS_EVENTCALLBACK) {
                 if (*duration != *period)
-                    hr = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
+                    params.result = AUDCLNT_E_BUFDURATION_PERIOD_NOT_EQUAL;
 
                 FIXME("EXCLUSIVE mode with EVENTCALLBACK\n");
 
-                hr = AUDCLNT_E_DEVICE_IN_USE;
+                params.result = AUDCLNT_E_DEVICE_IN_USE;
             } else if (*duration < 8 * *period)
                 *duration = 8 * *period; /* May grow above 2s. */
         }
@@ -162,7 +151,7 @@ static HRESULT adjust_timing(struct audio_client *client,
 
     TRACE("Adjusted duration %lu and period %lu\n", (ULONG)*duration, (ULONG)*period);
 
-    return hr;
+    return params.result;
 }
 
 static void dump_fmt(const WAVEFORMATEX *fmt)
@@ -759,13 +748,21 @@ static HRESULT WINAPI client_GetDevicePeriod(IAudioClient3 *iface, REFERENCE_TIM
                                       REFERENCE_TIME *minperiod)
 {
     struct audio_client *This = impl_from_IAudioClient3(iface);
+    struct get_device_period_params params;
 
     TRACE("(%p)->(%p, %p)\n", This, defperiod, minperiod);
 
     if (!defperiod && !minperiod)
         return E_POINTER;
 
-    return get_periods(This, defperiod, minperiod);
+    params.device     = This->device_name;
+    params.flow       = This->dataflow;
+    params.def_period = defperiod;
+    params.min_period = minperiod;
+
+    wine_unix_call(get_device_period, &params);
+
+    return params.result;
 }
 
 static HRESULT WINAPI client_Start(IAudioClient3 *iface)
-- 
2.45.2

