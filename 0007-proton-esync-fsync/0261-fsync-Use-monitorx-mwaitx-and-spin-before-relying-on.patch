From 2d36d872817b83ef237f5a3561d8504db0d5a0ca Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Fri, 8 Nov 2024 17:14:10 -0800
Subject: [PATCH] fsync: Use monitorx+mwaitx and spin before relying on
 futex_waitv.

Inspired by a patch by Torge Matthies.
---
 dlls/ntdll/unix/fsync.c | 85 ++++++++++++++++++++++++++++++++++++++++-
 dlls/ntdll/unix/fsync.h | 62 ++++++++++++++++++++++++++++++
 2 files changed, 146 insertions(+), 1 deletion(-)

diff --git a/dlls/ntdll/unix/fsync.c b/dlls/ntdll/unix/fsync.c
index 169ceab10ad..ec5df6cbb3c 100644
--- a/dlls/ntdll/unix/fsync.c
+++ b/dlls/ntdll/unix/fsync.c
@@ -773,6 +773,52 @@ static NTSTATUS do_single_wait( int *addr, int val, const struct timespec64 *end
         return STATUS_PENDING;
 }
 
+/* Fast path attempt to detect a value change using monitorx/mwaitx and spinning
+ * Returns STATUS_SUCCESS if the value changed, STATUS_UNSUCCESSFUL if it did not
+ * observed_val: If non-NULL, receives the last observed value */
+static inline NTSTATUS try_wait_value( volatile int *addr, int expected_val, int *observed_val,
+    const unsigned int mon_timeout, const unsigned int max_spin )
+{
+    unsigned int spin = 0;
+    unsigned int spin_i = 0;
+    int val;
+
+    /* Check again before doing any waiting/spinning */
+    val = __atomic_load_n( addr, __ATOMIC_SEQ_CST );
+    if (val != expected_val)
+    {
+        if (observed_val) *observed_val = val;
+        return STATUS_SUCCESS;
+    }
+
+    if (mwaitx_supported())
+    {
+        val = monitor_wait( addr, expected_val, mon_timeout );
+        if (val != expected_val)
+        {
+            if (observed_val) *observed_val = val;
+            return STATUS_SUCCESS;
+        }
+    }
+
+    /* Fall through to spinning with exponential backoff */
+    while (spin++ < max_spin)
+    {
+        val = __atomic_load_n( addr, __ATOMIC_SEQ_CST );
+        if (val != expected_val)
+        {
+            if (observed_val) *observed_val = val;
+            return STATUS_SUCCESS;
+        }
+
+        for (spin_i = 0; spin_i < (spin > 4 ? (1U << (spin - 4)) : 4); spin_i++)
+            YieldProcessor();
+    }
+
+    if (observed_val) *observed_val = val;
+    return STATUS_UNSUCCESSFUL;
+}
+
 static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
     BOOLEAN wait_any, BOOLEAN alertable, const LARGE_INTEGER *timeout )
 {
@@ -929,6 +975,29 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             return STATUS_ABANDONED_WAIT_0 + i;
                         }
 
+                        if (try_wait_value( &mutex->tid, tid, &tid, 500, 2 ) == STATUS_SUCCESS)
+                        {
+                            if (tid == current_tid)
+                            {
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                mutex->count++;
+                                return i;
+                            }
+                            if (tid == 0)
+                            {
+                                TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                                mutex->tid = current_tid;
+                                mutex->count = 1;
+                                return i;
+                            }
+                            if (tid == ~0)
+                            {
+                                TRACE("Woken up by abandoned mutex %p [%d].\n", handles[i], i);
+                                mutex->tid = current_tid;
+                                mutex->count = 1;
+                                return STATUS_ABANDONED_WAIT_0 + i;
+                            }
+                        }
                         futex_vector_set( &futexes[i], &mutex->tid, tid );
                         break;
                     }
@@ -942,6 +1011,13 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                             TRACE("Woken up by handle %p [%d].\n", handles[i], i);
                             return i;
                         }
+                        int signaled;
+                        if (try_wait_value( &event->signaled, 0, &signaled, 500, 2 ) == STATUS_SUCCESS && 
+                            signaled && __sync_val_compare_and_swap( &event->signaled, 1, 0 ))
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            return i;
+                        }
                         futex_vector_set( &futexes[i], &event->signaled, 0 );
                         break;
                     }
@@ -950,8 +1026,15 @@ static NTSTATUS __fsync_wait_objects( DWORD count, const HANDLE *handles,
                     case FSYNC_QUEUE:
                     {
                         struct event *event = obj->shm;
+                        int signaled = __atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST );
+
+                        if (signaled)
+                        {
+                            TRACE("Woken up by handle %p [%d].\n", handles[i], i);
+                            return i;
+                        }
 
-                        if (__atomic_load_n( &event->signaled, __ATOMIC_SEQ_CST ))
+                        if (try_wait_value( &event->signaled, 0, &signaled, 1500, 5 ) == STATUS_SUCCESS && signaled)
                         {
                             TRACE("Woken up by handle %p [%d].\n", handles[i], i);
                             return i;
diff --git a/dlls/ntdll/unix/fsync.h b/dlls/ntdll/unix/fsync.h
index 59013f83e7c..63691a0d207 100644
--- a/dlls/ntdll/unix/fsync.h
+++ b/dlls/ntdll/unix/fsync.h
@@ -58,3 +58,65 @@ static inline int get_cached_tid(void)
     static __thread int cached_tid;
     return cached_tid ? cached_tid : (cached_tid = GetCurrentThreadId());
 }
+
+#if defined(__x86_64__) || defined(__i386__)
+
+static inline int mwaitx_supported( void )
+{
+    static int supported;
+    if (!supported)
+    {
+        unsigned int eax, ecx;
+        __asm__ __volatile__ (
+            "cpuid"
+            : "=a" (eax), "=c" (ecx)
+            : "a" (0x80000001U)
+            : "ebx", "edx"
+        );
+        if (ecx & (1U << 29))
+            supported = 1;
+        else
+            supported = -1;
+    }
+    return supported > 0;
+}
+
+/* Monitor memory location for changes using MONITORX/MWAITX
+ * addr: Memory address to monitor 
+ * val: Expected value
+ * timeout: Max cycles to wait
+ * Returns: The current value at addr after monitoring
+ * 
+ * Note: monitorx/mwaitx act as full memory barriers, so this
+ * function provides sequential consistency for the monitored address */
+static inline int monitor_wait( volatile int *addr, int val, unsigned int timeout )
+{
+    /* monitorx setup - acts as acquire barrier */
+    __asm__ __volatile__ (
+        ".byte 0x0f,0x01,0xfa" /* monitorx */
+        :
+        : "a" (addr), "c" (0U), "d" (0U)
+        : "memory"
+    );
+
+    /* The value check is done after monitorx since monitorx 
+     * acts as an acquire barrier - if the value changed, we'll see it */
+    if (*addr != val)
+        return *addr;
+
+    /* mwaitx - acts as full barrier */    
+    __asm__ __volatile__ (
+        ".byte 0x0f,0x01,0xfb" /* mwaitx */
+        :
+        : "a" (0xF0U), "b" (timeout), "c" (0x2U)
+        : "memory"
+    );
+
+    /* mwaitx ensures we see latest value */
+    return *addr;
+}
+
+#else
+#define mwaitx_supported() 0
+static inline int monitor_wait( volatile int *addr, int val, unsigned int timeout ) {}
+#endif
-- 
2.47.0

