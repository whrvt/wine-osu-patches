diff --git a/dlls/winebus.sys/bus_udev.c b/dlls/winebus.sys/bus_udev.c
index 11111111111..11111111111 100644
--- a/dlls/winebus.sys/bus_udev.c
+++ b/dlls/winebus.sys/bus_udev.c
@@ -1300,6 +1300,12 @@ static void udev_add_device(struct udev_device *dev, int fd)
         return;
     }
 
+    if (desc.vid == 0x31e3) /* prevents usb_main_loop crashing when a keyboard key is pressed (wooting/linux firmware bug?) */
+    {
+        close(fd);
+        FIXME("not adding Wooting device\n");
+    }
+   
     if ((desc.is_hidraw = !strcmp(subsystem, "hidraw")) && !hidraw_device_create(dev, fd, devnode, desc)) return;
     if (!strcmp(subsystem, "input") && !lnxev_device_create(dev, fd, devnode, desc)) return;
     close(fd);
@@ -1706,7 +1712,7 @@ NTSTATUS udev_bus_init(void *args)
 
     if (monitor_fd < 0 && !(udev_monitor = create_monitor(&monitor_fd)))
     {
-        ERR("UDEV monitor creation failed\n");
+        WARN("UDEV monitor creation failed\n");
         goto error;
     }
 
diff --git a/dlls/winebus.sys/main.c b/dlls/winebus.sys/main.c
index 11111111111..11111111111 100644
--- a/dlls/winebus.sys/main.c
+++ b/dlls/winebus.sys/main.c
@@ -919,7 +919,7 @@ static void bus_options_init(void)
 {
     options.disable_sdl = !check_bus_option(L"Enable SDL", 1);
     if (options.disable_sdl) TRACE("SDL devices disabled in registry\n");
-    options.disable_hidraw = check_bus_option(L"DisableHidraw", 0);
+    options.disable_hidraw = check_bus_option(L"DisableHidraw", 1);
     if (options.disable_hidraw) TRACE("UDEV hidraw devices disabled in registry\n");
     options.disable_input = check_bus_option(L"DisableInput", 0);
     if (options.disable_input) TRACE("UDEV input devices disabled in registry\n");
diff --git a/dlls/wineusb.sys/wineusb.c b/dlls/wineusb.sys/wineusb.c
index 29d28ee002d..5139aef4549 100644
--- a/dlls/wineusb.sys/wineusb.c
+++ b/dlls/wineusb.sys/wineusb.c
@@ -428,7 +428,7 @@ static NTSTATUS query_id(struct usb_device *device, IRP *irp, BUS_QUERY_ID_TYPE
             break;
 
         default:
-            FIXME("Unhandled ID query type %#x.\n", type);
+            WARN("Unhandled ID query type %#x.\n", type);
             return irp->IoStatus.Status;
     }
 
