From 4fef6e48ae8f13abe3e4496ebd738b4212ab8aac Mon Sep 17 00:00:00 2001
From: Conor McCarthy <cmccarthy@codeweavers.com>
Date: Thu, 30 Jan 2025 15:44:45 +1000
Subject: [PATCH] rtworkq/tests: Test work queue.

---
 dlls/rtworkq/tests/rtworkq.c | 337 +++++++++++++++++++++++++++++++++++
 1 file changed, 337 insertions(+)

diff --git a/dlls/rtworkq/tests/rtworkq.c b/dlls/rtworkq/tests/rtworkq.c
index 2ff74d57b84..e7d59bae656 100644
--- a/dlls/rtworkq/tests/rtworkq.c
+++ b/dlls/rtworkq/tests/rtworkq.c
@@ -19,12 +19,156 @@
 #include <stdarg.h>
 #include <string.h>
 
+#define COBJMACROS
+
 #include "windef.h"
 #include "winbase.h"
+#include "initguid.h"
 #include "rtworkq.h"
 
 #include "wine/test.h"
 
+/* Should be kept in sync with corresponding MFASYNC_CALLBACK_ constants. */
+enum rtwq_callback_queue_id
+{
+    RTWQ_CALLBACK_QUEUE_UNDEFINED     = 0x00000000,
+    RTWQ_CALLBACK_QUEUE_STANDARD      = 0x00000001,
+    RTWQ_CALLBACK_QUEUE_RT            = 0x00000002,
+    RTWQ_CALLBACK_QUEUE_IO            = 0x00000003,
+    RTWQ_CALLBACK_QUEUE_TIMER         = 0x00000004,
+    RTWQ_CALLBACK_QUEUE_MULTITHREADED = 0x00000005,
+    RTWQ_CALLBACK_QUEUE_LONG_FUNCTION = 0x00000007,
+    RTWQ_CALLBACK_QUEUE_PRIVATE_MASK  = 0xffff0000,
+    RTWQ_CALLBACK_QUEUE_ALL           = 0xffffffff,
+};
+
+#define check_platform_lock_count(a) check_platform_lock_count_(__LINE__, a)
+static void check_platform_lock_count_(unsigned int line, unsigned int expected)
+{
+    int i, count = 0;
+    BOOL unexpected;
+    DWORD queue;
+    HRESULT hr;
+
+    for (;;)
+    {
+        if (FAILED(hr = RtwqAllocateWorkQueue(RTWQ_STANDARD_WORKQUEUE, &queue)))
+        {
+            unexpected = hr != RTWQ_E_SHUTDOWN;
+            break;
+        }
+        RtwqUnlockWorkQueue(queue);
+
+        hr = RtwqUnlockPlatform();
+        if ((unexpected = FAILED(hr)))
+            break;
+
+        ++count;
+    }
+
+    for (i = 0; i < count; ++i)
+        RtwqLockPlatform();
+
+    if (unexpected)
+        count = -1;
+
+    ok_(__FILE__, line)(count == expected, "Unexpected lock count %d.\n", count);
+}
+
+struct test_callback
+{
+    IRtwqAsyncCallback IRtwqAsyncCallback_iface;
+    LONG refcount;
+    HANDLE event;
+    IRtwqAsyncResult *result;
+};
+
+static struct test_callback *impl_from_IRtwqAsyncCallback(IRtwqAsyncCallback *iface)
+{
+    return CONTAINING_RECORD(iface, struct test_callback, IRtwqAsyncCallback_iface);
+}
+
+static HRESULT WINAPI testcallback_QueryInterface(IRtwqAsyncCallback *iface, REFIID riid, void **obj)
+{
+    if (IsEqualIID(riid, &IID_IRtwqAsyncCallback) ||
+            IsEqualIID(riid, &IID_IUnknown))
+    {
+        *obj = iface;
+        IRtwqAsyncCallback_AddRef(iface);
+        return S_OK;
+    }
+
+    *obj = NULL;
+    return E_NOINTERFACE;
+}
+
+static ULONG WINAPI testcallback_AddRef(IRtwqAsyncCallback *iface)
+{
+    struct test_callback *callback = impl_from_IRtwqAsyncCallback(iface);
+    return InterlockedIncrement(&callback->refcount);
+}
+
+static ULONG WINAPI testcallback_Release(IRtwqAsyncCallback *iface)
+{
+    struct test_callback *callback = impl_from_IRtwqAsyncCallback(iface);
+    ULONG refcount = InterlockedDecrement(&callback->refcount);
+
+    if (!refcount)
+    {
+        CloseHandle(callback->event);
+        free(callback);
+    }
+
+    return refcount;
+}
+
+static HRESULT WINAPI testcallback_GetParameters(IRtwqAsyncCallback *iface, DWORD *flags, DWORD *queue)
+{
+    ok(flags != NULL && queue != NULL, "Unexpected arguments.\n");
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI testcallback_Invoke(IRtwqAsyncCallback *iface, IRtwqAsyncResult *result)
+{
+    struct test_callback *callback = impl_from_IRtwqAsyncCallback(iface);
+
+    callback->result = result;
+    SetEvent(callback->event);
+
+    return S_OK;
+}
+
+static const IRtwqAsyncCallbackVtbl testcallbackvtbl =
+{
+    testcallback_QueryInterface,
+    testcallback_AddRef,
+    testcallback_Release,
+    testcallback_GetParameters,
+    testcallback_Invoke,
+};
+
+static struct test_callback * create_test_callback(void)
+{
+    struct test_callback *callback = calloc(1, sizeof(*callback));
+
+    callback->IRtwqAsyncCallback_iface.lpVtbl = &testcallbackvtbl;
+    callback->refcount = 1;
+    callback->event = CreateEventA(NULL, FALSE, FALSE, NULL);
+
+    return callback;
+}
+
+static DWORD wait_async_callback_result(IRtwqAsyncCallback *iface, DWORD timeout, IRtwqAsyncResult **result)
+{
+    struct test_callback *callback = impl_from_IRtwqAsyncCallback(iface);
+    DWORD res = WaitForSingleObject(callback->event, timeout);
+
+    *result = callback->result;
+    callback->result = NULL;
+
+    return res;
+}
+
 static void test_platform_init(void)
 {
     APTTYPEQUALIFIER qualifier;
@@ -101,7 +245,200 @@ static void test_platform_init(void)
     ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
 }
 
+static void test_work_queue(void)
+{
+    IRtwqAsyncResult *result, *result2, *callback_result;
+    struct test_callback *test_callback;
+    RTWQWORKITEM_KEY key, key2;
+    DWORD res, queue;
+    LONG refcount;
+    HRESULT hr;
+
+    hr = RtwqLockPlatform();
+    ok(hr == S_OK, "Failed to lock, %#lx.\n", hr);
+    hr = RtwqAllocateWorkQueue(RTWQ_STANDARD_WORKQUEUE, &queue);
+    todo_wine
+    ok(hr == RTWQ_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    hr = RtwqUnlockPlatform();
+    ok(hr == S_OK, "Failed to unlock, %#lx.\n", hr);
+
+    test_callback = create_test_callback();
+
+    /* Create async results without startup. */
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result2);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    IRtwqAsyncResult_Release(result);
+    IRtwqAsyncResult_Release(result2);
+
+    hr = RtwqStartup();
+    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    /* Before startup the platform lock count does not track the maximum AsyncResult count. */
+    check_platform_lock_count(1);
+
+    hr = RtwqStartup();
+    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    /* Startup only locks once. */
+    todo_wine
+    check_platform_lock_count(1);
+    hr = RtwqShutdown();
+    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    /* Platform locked by the AsyncResult object. */
+    check_platform_lock_count(2);
+
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result2);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    check_platform_lock_count(3);
+
+    IRtwqAsyncResult_Release(result);
+    IRtwqAsyncResult_Release(result2);
+    /* Platform lock count for AsyncResult objects does not decrease
+     * unless the platform is in shutdown state. */
+    todo_wine
+    check_platform_lock_count(3);
+
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    /* Platform lock count tracks the maximum AsyncResult count plus one for startup. */
+    todo_wine
+    check_platform_lock_count(3);
+
+    hr = RtwqPutWorkItem(RTWQ_CALLBACK_QUEUE_STANDARD, 0, result);
+    ok(hr == S_OK, "got %#lx\n", hr);
+    res = wait_async_callback_result(&test_callback->IRtwqAsyncCallback_iface, 100, &callback_result);
+    ok(res == 0, "got %#lx\n", res);
+    /* TODO: Wine often has a release call pending in another thread at this point. */
+    refcount = IRtwqAsyncResult_Release(result);
+    flaky_wine
+    todo_wine
+    ok(!refcount, "Unexpected refcount %ld.\n", refcount);
+    todo_wine
+    check_platform_lock_count(3);
+
+    hr = RtwqLockPlatform();
+    ok(hr == S_OK, "Failed to lock, %#lx.\n", hr);
+    hr = RtwqLockPlatform();
+    ok(hr == S_OK, "Failed to lock, %#lx.\n", hr);
+    todo_wine
+    check_platform_lock_count(5);
+
+    hr = RtwqShutdown();
+    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+
+    /* Platform is in shutdown state if either the lock count or the startup count is <= 0. */
+    hr = RtwqAllocateWorkQueue(RTWQ_STANDARD_WORKQUEUE, &queue);
+    todo_wine
+    ok(hr == RTWQ_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+
+    /* Platform can be unlocked after shutdown. */
+    hr = RtwqUnlockPlatform();
+    ok(hr == S_OK, "Failed to unlock, %#lx.\n", hr);
+
+    hr = RtwqStartup();
+    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+
+    /* Platform locks for AsyncResult objects were released on shutdown, but the explicit lock was not. */
+    check_platform_lock_count(2);
+    hr = RtwqUnlockPlatform();
+    ok(hr == S_OK, "Failed to unlock, %#lx.\n", hr);
+    check_platform_lock_count(1);
+
+    hr = RtwqUnlockPlatform();
+    ok(hr == S_OK, "Failed to unlock, %#lx.\n", hr);
+    /* Zero lock count. */
+    hr = RtwqAllocateWorkQueue(RTWQ_STANDARD_WORKQUEUE, &queue);
+    ok(hr == RTWQ_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    hr = RtwqUnlockPlatform();
+    ok(hr == S_OK, "Failed to unlock, %#lx.\n", hr);
+    /* Negative lock count. */
+    hr = RtwqAllocateWorkQueue(RTWQ_STANDARD_WORKQUEUE, &queue);
+    ok(hr == RTWQ_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+    hr = RtwqLockPlatform();
+    ok(hr == S_OK, "Failed to lock, %#lx.\n", hr);
+    hr = RtwqLockPlatform();
+    ok(hr == S_OK, "Failed to lock, %#lx.\n", hr);
+    check_platform_lock_count(1);
+
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    check_platform_lock_count(2);
+
+    hr = RtwqShutdown();
+    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+
+    /* Release an AsyncResult object after shutdown. Platform lock count tracks the AsyncResult
+     * count. It's not possible to show if unlock occurs immedately or on the next startup. */
+    IRtwqAsyncResult_Release(result);
+    hr = RtwqStartup();
+    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    check_platform_lock_count(1);
+
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    hr = RtwqShutdown();
+    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    hr = RtwqStartup();
+    ok(hr == S_OK, "Failed to start up, hr %#lx.\n", hr);
+    check_platform_lock_count(2);
+    /* Release an AsyncResult object after shutdown and startup. */
+    IRtwqAsyncResult_Release(result);
+    todo_wine
+    check_platform_lock_count(2);
+
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    hr = RtwqScheduleWorkItem(result, -5000, &key);
+    ok(hr == S_OK, "Failed to schedule item, hr %#lx.\n", hr);
+    check_platform_lock_count(2);
+
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result2);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    hr = RtwqScheduleWorkItem(result2, -5000, &key2);
+    ok(hr == S_OK, "Failed to schedule item, hr %#lx.\n", hr);
+    check_platform_lock_count(3);
+
+    hr = RtwqCancelWorkItem(key);
+    ok(hr == S_OK, "Failed to cancel item, hr %#lx.\n", hr);
+    hr = RtwqCancelWorkItem(key2);
+    ok(hr == S_OK, "Failed to cancel item, hr %#lx.\n", hr);
+    IRtwqAsyncResult_Release(result);
+    IRtwqAsyncResult_Release(result2);
+    todo_wine
+    check_platform_lock_count(3);
+
+    hr = RtwqCreateAsyncResult(NULL, &test_callback->IRtwqAsyncCallback_iface, NULL, &result);
+    ok(hr == S_OK, "Failed to create result, hr %#lx.\n", hr);
+    hr = RtwqScheduleWorkItem(result, -5000, &key);
+    ok(hr == S_OK, "Failed to schedule item, hr %#lx.\n", hr);
+    todo_wine
+    check_platform_lock_count(3);
+
+    hr = RtwqShutdown();
+    ok(hr == S_OK, "Failed to shut down, hr %#lx.\n", hr);
+    /* Shutdown while a scheduled item is pending leaks the AsyncResult. */
+    refcount = IRtwqAsyncResult_Release(result);
+    ok(refcount == 1, "Unexpected refcount %ld.\n", refcount);
+    IRtwqAsyncResult_Release(result);
+
+    hr = RtwqAllocateWorkQueue(RTWQ_STANDARD_WORKQUEUE, &queue);
+    ok(hr == RTWQ_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+
+    hr = RtwqCancelWorkItem(key);
+    todo_wine
+    ok(hr == RTWQ_E_SHUTDOWN, "Unexpected hr %#lx.\n", hr);
+
+    res = wait_async_callback_result(&test_callback->IRtwqAsyncCallback_iface, 0, &callback_result);
+    ok(res == WAIT_TIMEOUT, "got res %#lx\n", res);
+
+    IRtwqAsyncCallback_Release(&test_callback->IRtwqAsyncCallback_iface);
+}
+
 START_TEST(rtworkq)
 {
     test_platform_init();
+    test_work_queue();
 }
-- 
GitLab

