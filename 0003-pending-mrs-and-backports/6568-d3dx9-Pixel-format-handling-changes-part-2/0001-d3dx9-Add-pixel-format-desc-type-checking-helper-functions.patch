From 1f35c1d57165dcb51311961f40db431b71d93e2b Mon Sep 17 00:00:00 2001
From: Connor McAdams <cmcadams@codeweavers.com>
Date: Mon, 8 Jul 2024 07:22:36 -0400
Subject: [PATCH] d3dx9: Add pixel_format_desc type checking helper functions.

Signed-off-by: Connor McAdams <cmcadams@codeweavers.com>
---
 dlls/d3dx9_36/d3dx9_private.h | 30 ++++++++++++++++++++++--------
 dlls/d3dx9_36/math.c          |  2 +-
 dlls/d3dx9_36/surface.c       | 24 ++++++++++++------------
 dlls/d3dx9_36/texture.c       |  8 ++++----
 dlls/d3dx9_36/volume.c        |  4 ++--
 5 files changed, 41 insertions(+), 27 deletions(-)

diff --git a/dlls/d3dx9_36/d3dx9_private.h b/dlls/d3dx9_36/d3dx9_private.h
index e46cd7389b2..eb2594a43fa 100644
--- a/dlls/d3dx9_36/d3dx9_private.h
+++ b/dlls/d3dx9_36/d3dx9_private.h
@@ -173,20 +173,34 @@ struct d3dx_include_from_file
 extern CRITICAL_SECTION from_file_mutex;
 extern const struct ID3DXIncludeVtbl d3dx_include_from_file_vtbl;
 
+static inline BOOL is_unknown_format(const struct pixel_format_desc *format)
+{
+    return (format->format == D3DFMT_UNKNOWN);
+}
+
+static inline BOOL is_index_format(const struct pixel_format_desc *format)
+{
+    return (format->type == FORMAT_INDEX);
+}
+
+static inline BOOL is_compressed_format(const struct pixel_format_desc *format)
+{
+    return (format->type == FORMAT_DXT);
+}
+
+static inline BOOL format_types_match(const struct pixel_format_desc *src, const struct pixel_format_desc *dst)
+{
+    return (src->type == dst->type);
+}
+
 static inline BOOL is_conversion_from_supported(const struct pixel_format_desc *format)
 {
-    if (format->type == FORMAT_ARGB || format->type == FORMAT_ARGBF16
-            || format->type == FORMAT_ARGBF || format->type == FORMAT_DXT || format->type == FORMAT_ARGB_SNORM)
-        return TRUE;
-    return !!format->to_rgba;
+    return !is_unknown_format(format);
 }
 
 static inline BOOL is_conversion_to_supported(const struct pixel_format_desc *format)
 {
-    if (format->type == FORMAT_ARGB || format->type == FORMAT_ARGBF16
-            || format->type == FORMAT_ARGBF || format->type == FORMAT_DXT || format->type == FORMAT_ARGB_SNORM)
-        return TRUE;
-    return !!format->from_rgba;
+    return !is_index_format(format) && !is_unknown_format(format);
 }
 
 HRESULT map_view_of_file(const WCHAR *filename, void **buffer, DWORD *length);
diff --git a/dlls/d3dx9_36/math.c b/dlls/d3dx9_36/math.c
index 4b8f200b199..f256b7b2662 100644
--- a/dlls/d3dx9_36/math.c
+++ b/dlls/d3dx9_36/math.c
@@ -3017,7 +3017,7 @@ HRESULT WINAPI D3DXSHProjectCubeMap(unsigned int order, IDirect3DCubeTexture9 *t
     }
 
     format = get_format_info(desc.Format);
-    if (format->type != FORMAT_ARGB && format->type != FORMAT_ARGBF16 && format->type != FORMAT_ARGBF)
+    if (is_unknown_format(format) || is_index_format(format) || is_compressed_format(format))
     {
         FIXME("Unsupported texture format %#x.\n", desc.Format);
         return D3DERR_INVALIDCALL;
diff --git a/dlls/d3dx9_36/surface.c b/dlls/d3dx9_36/surface.c
index 7ffc11af663..fa9db1167f2 100644
--- a/dlls/d3dx9_36/surface.c
+++ b/dlls/d3dx9_36/surface.c
@@ -457,7 +457,7 @@ static HRESULT d3dx_calculate_pixels_size(D3DFORMAT format, uint32_t width, uint
 {
     const struct pixel_format_desc *format_desc = get_format_info(format);
 
-    if (format_desc->type == FORMAT_UNKNOWN)
+    if (is_unknown_format(format_desc))
         return E_NOTIMPL;
 
     if (format_desc->block_width != 1 || format_desc->block_height != 1)
@@ -539,7 +539,7 @@ static HRESULT save_dds_surface_to_memory(ID3DXBuffer **dst_buffer, IDirect3DSur
     if (FAILED(hr)) return hr;
 
     pixel_format = get_format_info(src_desc.Format);
-    if (pixel_format->type == FORMAT_UNKNOWN) return E_NOTIMPL;
+    if (is_unknown_format(pixel_format)) return E_NOTIMPL;
 
     file_size = calculate_dds_file_size(src_desc.Format, src_desc.Width, src_desc.Height, 1, 1, 1);
     if (!file_size)
@@ -847,7 +847,7 @@ static HRESULT d3dx_image_wic_frame_decode(struct d3dx_image *image,
         return hr;
     }
 
-    if (fmt_desc->type == FORMAT_INDEX)
+    if (is_index_format(fmt_desc))
     {
         uint32_t nb_colors, i;
 
@@ -1712,7 +1712,7 @@ void convert_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slice_pit
 
             for (x = 0; x < min_width; x++) {
                 if (!src_format->to_rgba && !dst_format->from_rgba
-                        && src_format->type == dst_format->type
+                        && format_types_match(src_format, dst_format)
                         && src_format->bytes_per_pixel <= 4 && dst_format->bytes_per_pixel <= 4)
                 {
                     DWORD val;
@@ -1818,7 +1818,7 @@ void point_filter_argb_pixels(const BYTE *src, UINT src_row_pitch, UINT src_slic
                 const BYTE *src_ptr = src_row_ptr + (x * src_size->width / dst_size->width) * src_format->bytes_per_pixel;
 
                 if (!src_format->to_rgba && !dst_format->from_rgba
-                        && src_format->type == dst_format->type
+                        && format_types_match(src_format, dst_format)
                         && src_format->bytes_per_pixel <= 4 && dst_format->bytes_per_pixel <= 4)
                 {
                     DWORD val;
@@ -1963,7 +1963,7 @@ HRESULT d3dx_pixels_init(const void *data, uint32_t row_pitch, uint32_t slice_pi
     RECT unaligned_rect;
 
     memset(pixels, 0, sizeof(*pixels));
-    if (fmt_desc->type == FORMAT_UNKNOWN)
+    if (is_unknown_format(fmt_desc))
     {
         FIXME("Unsupported format %#x.\n", format);
         return E_NOTIMPL;
@@ -1973,7 +1973,7 @@ HRESULT d3dx_pixels_init(const void *data, uint32_t row_pitch, uint32_t slice_pi
     ptr += (top / fmt_desc->block_height) * row_pitch;
     ptr += (left / fmt_desc->block_width) * fmt_desc->block_byte_count;
 
-    if (fmt_desc->type == FORMAT_DXT)
+    if (is_compressed_format(fmt_desc))
     {
         uint32_t left_aligned, top_aligned;
 
@@ -2013,14 +2013,14 @@ HRESULT d3dx_load_pixels_from_pixels(struct d3dx_pixels *dst_pixels,
             debug_d3dx_pixels(dst_pixels), dst_desc, debug_d3dx_pixels(src_pixels), src_desc,
             filter_flags, color_key);
 
-    if (src_desc->type == FORMAT_DXT)
+    if (is_compressed_format(src_desc))
         set_volume_struct(&src_size, (src_pixels->unaligned_rect.right - src_pixels->unaligned_rect.left),
                 (src_pixels->unaligned_rect.bottom - src_pixels->unaligned_rect.top), src_pixels->size.depth);
     else
         src_size = src_pixels->size;
 
     dst_size_aligned = dst_pixels->size;
-    if (dst_desc->type == FORMAT_DXT)
+    if (is_compressed_format(dst_desc))
         set_volume_struct(&dst_size, (dst_pixels->unaligned_rect.right - dst_pixels->unaligned_rect.left),
                 (dst_pixels->unaligned_rect.bottom - dst_pixels->unaligned_rect.top), dst_pixels->size.depth);
     else
@@ -2055,7 +2055,7 @@ HRESULT d3dx_load_pixels_from_pixels(struct d3dx_pixels *dst_pixels,
      * If the source is a compressed image, we need to decompress it first
      * before doing any modifications.
      */
-    if (src_desc->type == FORMAT_DXT)
+    if (is_compressed_format(src_desc))
     {
         uint32_t uncompressed_row_pitch, uncompressed_slice_pitch;
         const struct pixel_format_desc *uncompressed_desc;
@@ -2079,7 +2079,7 @@ HRESULT d3dx_load_pixels_from_pixels(struct d3dx_pixels *dst_pixels,
     }
 
     /* Same as the above, need to decompress the destination prior to modifying. */
-    if (dst_desc->type == FORMAT_DXT)
+    if (is_compressed_format(dst_desc))
     {
         uint32_t uncompressed_row_pitch, uncompressed_slice_pitch;
         const struct pixel_format_desc *uncompressed_desc;
@@ -2238,7 +2238,7 @@ HRESULT WINAPI D3DXLoadSurfaceFromMemory(IDirect3DSurface9 *dst_surface,
     }
 
     srcformatdesc = get_format_info(src_format);
-    if (srcformatdesc->type == FORMAT_UNKNOWN)
+    if (is_unknown_format(srcformatdesc))
     {
         FIXME("Unsupported format %#x.\n", src_format);
         return E_NOTIMPL;
diff --git a/dlls/d3dx9_36/texture.c b/dlls/d3dx9_36/texture.c
index 38a32052f99..73d52f16a42 100644
--- a/dlls/d3dx9_36/texture.c
+++ b/dlls/d3dx9_36/texture.c
@@ -290,7 +290,7 @@ static HRESULT check_texture_requirements(struct IDirect3DDevice9 *device, UINT
 
             /* This format can be used, let's evaluate it.
                Weights chosen quite arbitrarily... */
-            score = 512 * (curfmt->type == fmt->type);
+            score = 512 * (format_types_match(curfmt, fmt));
             score -= 32 * (curchannels - channels);
 
             for (j = 0; j < 4; j++)
@@ -1287,7 +1287,7 @@ HRESULT WINAPI D3DXFillTexture(struct IDirect3DTexture9 *texture, LPD3DXFILL2D f
             return hr;
 
         format = get_format_info(desc.Format);
-        if (format->type != FORMAT_ARGB && format->type != FORMAT_ARGBF16 && format->type != FORMAT_ARGBF)
+        if (is_unknown_format(format) || is_index_format(format) || is_compressed_format(format))
         {
             FIXME("Unsupported texture format %#x.\n", desc.Format);
             return D3DERR_INVALIDCALL;
@@ -1684,7 +1684,7 @@ HRESULT WINAPI D3DXFillCubeTexture(struct IDirect3DCubeTexture9 *texture, LPD3DX
             return D3DERR_INVALIDCALL;
 
         format = get_format_info(desc.Format);
-        if (format->type != FORMAT_ARGB && format->type != FORMAT_ARGBF16 && format->type != FORMAT_ARGBF)
+        if (is_unknown_format(format) || is_index_format(format) || is_compressed_format(format))
         {
             FIXME("Unsupported texture format %#x\n", desc.Format);
             return D3DERR_INVALIDCALL;
@@ -1749,7 +1749,7 @@ HRESULT WINAPI D3DXFillVolumeTexture(struct IDirect3DVolumeTexture9 *texture, LP
             return D3DERR_INVALIDCALL;
 
         format = get_format_info(desc.Format);
-        if (format->type != FORMAT_ARGB && format->type != FORMAT_ARGBF16 && format->type != FORMAT_ARGBF)
+        if (is_unknown_format(format) || is_index_format(format) || is_compressed_format(format))
         {
             FIXME("Unsupported texture format %#x\n", desc.Format);
             return D3DERR_INVALIDCALL;
diff --git a/dlls/d3dx9_36/volume.c b/dlls/d3dx9_36/volume.c
index ae14e47b8b6..0d7fe4a7870 100644
--- a/dlls/d3dx9_36/volume.c
+++ b/dlls/d3dx9_36/volume.c
@@ -112,12 +112,12 @@ HRESULT WINAPI D3DXLoadVolumeFromMemory(IDirect3DVolume9 *dst_volume,
         return hr;
 
     src_format_desc = get_format_info(src_format);
-    if (src_format_desc->type == FORMAT_UNKNOWN)
+    if (is_unknown_format(src_format_desc))
         return E_NOTIMPL;
 
     IDirect3DVolume9_GetDesc(dst_volume, &desc);
     dst_format_desc = get_format_info(desc.Format);
-    if (dst_format_desc->type == FORMAT_UNKNOWN)
+    if (is_unknown_format(dst_format_desc))
         return E_NOTIMPL;
 
     if (!dst_box)
-- 
GitLab

