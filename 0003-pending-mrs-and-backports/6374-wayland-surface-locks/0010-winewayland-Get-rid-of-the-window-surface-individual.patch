From 8c3fe2546655e234494b984fba723668d0453023 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 20 Aug 2024 14:49:49 +0200
Subject: [PATCH 10/10] winewayland: Get rid of the window surface individual
 locks.

---
 dlls/winewayland.drv/opengl.c           | 53 +++++++++++--------
 dlls/winewayland.drv/vulkan.c           | 28 +++++-----
 dlls/winewayland.drv/wayland_keyboard.c | 10 ++--
 dlls/winewayland.drv/wayland_pointer.c  | 39 +++++++++-----
 dlls/winewayland.drv/wayland_surface.c  | 30 +++++------
 dlls/winewayland.drv/waylanddrv.h       |  2 -
 dlls/winewayland.drv/window.c           | 68 ++++++++++---------------
 7 files changed, 117 insertions(+), 113 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index fe7499f5256..94ff32c81f1 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -166,12 +166,12 @@ static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
     if (gl->client)
     {
         HWND hwnd = wl_surface_get_user_data(gl->client->wl_surface);
-        struct wayland_surface *wayland_surface = wayland_surface_lock_hwnd(hwnd);
+        struct wayland_win_data *data = wayland_win_data_get(hwnd);
 
-        if (wayland_client_surface_release(gl->client) && wayland_surface)
-            wayland_surface->client = NULL;
+        if (wayland_client_surface_release(gl->client) && data && data->wayland_surface)
+            data->wayland_surface->client = NULL;
 
-        if (wayland_surface) pthread_mutex_unlock(&wayland_surface->mutex);
+        if (data) wayland_win_data_release(data);
     }
 
     free(gl);
@@ -194,6 +194,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     struct wayland_gl_drawable *gl;
     struct wayland_surface *wayland_surface;
     int client_width = 0, client_height = 0;
+    struct wayland_win_data *data;
 
     TRACE("hwnd=%p format=%d\n", hwnd, format);
 
@@ -207,16 +208,24 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     /* Get the client surface for the HWND. If don't have a wayland surface
      * (e.g., HWND_MESSAGE windows) just create a dummy surface to act as the
      * target render surface. */
-    if ((wayland_surface = wayland_surface_lock_hwnd(hwnd)))
+    if ((data = wayland_win_data_get(hwnd)))
     {
-        gl->client = wayland_surface_get_client(wayland_surface);
-        client_width = wayland_surface->window.client_rect.right -
-                       wayland_surface->window.client_rect.left;
-        client_height = wayland_surface->window.client_rect.bottom -
-                        wayland_surface->window.client_rect.top;
-        if (client_width == 0 || client_height == 0)
+        if (!(wayland_surface = data->wayland_surface))
+        {
+            gl->client = wayland_client_surface_create(hwnd);
             client_width = client_height = 1;
-        pthread_mutex_unlock(&wayland_surface->mutex);
+        }
+        else
+        {
+            gl->client = wayland_surface_get_client(wayland_surface);
+            client_width = wayland_surface->window.client_rect.right -
+                           wayland_surface->window.client_rect.left;
+            client_height = wayland_surface->window.client_rect.bottom -
+                            wayland_surface->window.client_rect.top;
+            if (client_width == 0 || client_height == 0)
+                client_width = client_height = 1;
+        }
+        wayland_win_data_release(data);
     }
     else
     {
@@ -285,23 +294,27 @@ static void wayland_update_gl_drawable(HWND hwnd, struct wayland_gl_drawable *ne
 
 static void wayland_gl_drawable_sync_size(struct wayland_gl_drawable *gl)
 {
-    int client_width, client_height;
+    int client_width = 0, client_height = 0;
     struct wayland_surface *wayland_surface;
+    struct wayland_win_data *data;
 
     if (InterlockedCompareExchange(&gl->resized, FALSE, TRUE))
     {
-        if (!(wayland_surface = wayland_surface_lock_hwnd(gl->hwnd))) return;
+        if (!(data = wayland_win_data_get(gl->hwnd))) return;
+
+        if ((wayland_surface = data->wayland_surface))
+        {
+            client_width = wayland_surface->window.client_rect.right -
+                           wayland_surface->window.client_rect.left;
+            client_height = wayland_surface->window.client_rect.bottom -
+                            wayland_surface->window.client_rect.top;
+        }
 
-        client_width = wayland_surface->window.client_rect.right -
-                       wayland_surface->window.client_rect.left;
-        client_height = wayland_surface->window.client_rect.bottom -
-                        wayland_surface->window.client_rect.top;
         if (client_width == 0 || client_height == 0)
             client_width = client_height = 1;
+        wayland_win_data_release(data);
 
         wl_egl_window_resize(gl->wl_egl_window, client_width, client_height, 0, 0);
-
-        pthread_mutex_unlock(&wayland_surface->mutex);
     }
 }
 
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index a828d736da1..7a075a925b7 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -58,22 +58,15 @@ static VkBool32 (*pvkGetPhysicalDeviceWaylandPresentationSupportKHR)(VkPhysicalD
 
 static const struct vulkan_driver_funcs wayland_vulkan_driver_funcs;
 
-static HWND wine_vk_surface_get_hwnd(struct wayland_client_surface *client)
-{
-    return wl_surface_get_user_data(client->wl_surface);
-}
-
 static void wine_vk_surface_destroy(struct wayland_client_surface *client)
 {
-    HWND hwnd = wine_vk_surface_get_hwnd(client);
-    struct wayland_surface *wayland_surface = wayland_surface_lock_hwnd(hwnd);
+    HWND hwnd = wl_surface_get_user_data(client->wl_surface);
+    struct wayland_win_data *data = wayland_win_data_get(hwnd);
 
-    if (wayland_client_surface_release(client) && wayland_surface)
-    {
-        wayland_surface->client = NULL;
-    }
+    if (wayland_client_surface_release(client) && data && data->wayland_surface)
+        data->wayland_surface->client = NULL;
 
-    if (wayland_surface) pthread_mutex_unlock(&wayland_surface->mutex);
+    if (data) wayland_win_data_release(data);
 }
 
 static VkResult wayland_vulkan_surface_create(HWND hwnd, VkInstance instance, VkSurfaceKHR *surface, void **private)
@@ -82,18 +75,21 @@ static VkResult wayland_vulkan_surface_create(HWND hwnd, VkInstance instance, Vk
     VkWaylandSurfaceCreateInfoKHR create_info_host;
     struct wayland_surface *wayland_surface;
     struct wayland_client_surface *client;
+    struct wayland_win_data *data;
 
     TRACE("%p %p %p %p\n", hwnd, instance, surface, private);
 
-    wayland_surface = wayland_surface_lock_hwnd(hwnd);
-    if (!wayland_surface)
+    if (!(data = wayland_win_data_get(hwnd)))
     {
         ERR("Failed to find wayland surface for hwnd=%p\n", hwnd);
         return VK_ERROR_OUT_OF_HOST_MEMORY;
     }
 
-    client = wayland_surface_get_client(wayland_surface);
-    pthread_mutex_unlock(&wayland_surface->mutex);
+    if ((wayland_surface = data->wayland_surface))
+        client = wayland_surface_get_client(wayland_surface);
+    else
+        client = wayland_client_surface_create(hwnd);
+    wayland_win_data_release(data);
 
     if (!client)
     {
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index 5c2fe15273e..8f7b6dce30f 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -736,12 +736,13 @@ static void keyboard_handle_keymap(void *data, struct wl_keyboard *wl_keyboard,
     xkb_keymap_unref(xkb_keymap);
 }
 
-static void keyboard_handle_enter(void *data, struct wl_keyboard *wl_keyboard,
+static void keyboard_handle_enter(void *private, struct wl_keyboard *wl_keyboard,
                                   uint32_t serial, struct wl_surface *wl_surface,
                                   struct wl_array *keys)
 {
     struct wayland_keyboard *keyboard = &process_wayland.keyboard;
     struct wayland_surface *surface;
+    struct wayland_win_data *data;
     HWND hwnd;
 
     if (!wl_surface) return;
@@ -758,7 +759,9 @@ static void keyboard_handle_enter(void *data, struct wl_keyboard *wl_keyboard,
     NtUserPostMessage(keyboard->focused_hwnd, WM_INPUTLANGCHANGEREQUEST, 0 /*FIXME*/,
                       (LPARAM)keyboard_hkl);
 
-    if ((surface = wayland_surface_lock_hwnd(hwnd)))
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    if ((surface = data->wayland_surface))
     {
         /* TODO: Drop the internal message and call NtUserSetForegroundWindow
          * directly once it's updated to not explicitly deactivate the old
@@ -766,8 +769,9 @@ static void keyboard_handle_enter(void *data, struct wl_keyboard *wl_keyboard,
          * are in the same non-current thread. */
         if (surface->window.managed)
             NtUserPostMessage(hwnd, WM_WAYLAND_SET_FOREGROUND, 0, 0);
-        pthread_mutex_unlock(&surface->mutex);
     }
+
+    wayland_win_data_release(data);
 }
 
 static void keyboard_handle_leave(void *data, struct wl_keyboard *wl_keyboard,
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index b549aa28257..66b39b12690 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -53,9 +53,15 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
     HWND hwnd;
     POINT screen;
     struct wayland_surface *surface;
+    struct wayland_win_data *data;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
-    if (!(surface = wayland_surface_lock_hwnd(hwnd))) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
+    if (!(surface = data->wayland_surface))
+    {
+        wayland_win_data_release(data);
+        return;
+    }
 
     window_rect = &surface->window.rect;
 
@@ -72,7 +78,7 @@ static void pointer_handle_motion_internal(wl_fixed_t sx, wl_fixed_t sy)
     if (screen.y >= window_rect->bottom) screen.y = window_rect->bottom - 1;
     else if (screen.y < window_rect->top) screen.y = window_rect->top;
 
-    pthread_mutex_unlock(&surface->mutex);
+    wayland_win_data_release(data);
 
     input.type = INPUT_MOUSE;
     input.mi.dx = screen.x;
@@ -245,7 +251,7 @@ static const struct wl_pointer_listener pointer_listener =
     pointer_handle_axis_discrete
 };
 
-static void relative_pointer_v1_relative_motion(void *data,
+static void relative_pointer_v1_relative_motion(void *private,
                                                 struct zwp_relative_pointer_v1 *zwp_relative_pointer_v1,
                                                 uint32_t utime_hi, uint32_t utime_lo,
                                                 wl_fixed_t dx, wl_fixed_t dy,
@@ -254,17 +260,18 @@ static void relative_pointer_v1_relative_motion(void *data,
     INPUT input = {0};
     HWND hwnd;
     POINT screen;
-    struct wayland_surface *surface;
+    struct wayland_win_data *data;
 
     if (!(hwnd = wayland_pointer_get_focused_hwnd())) return;
-    if (!(surface = wayland_surface_lock_hwnd(hwnd))) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
 
-    wayland_surface_coords_to_window(surface,
+    wayland_surface_coords_to_window(data->wayland_surface,
                                      wl_fixed_to_double(dx),
                                      wl_fixed_to_double(dy),
                                      (int *)&screen.x, (int *)&screen.y);
 
-    pthread_mutex_unlock(&surface->mutex);
+    wayland_win_data_release(data);
+
 
     input.type = INPUT_MOUSE;
     input.mi.dx = screen.x;
@@ -629,16 +636,22 @@ static void wayland_set_cursor(HWND hwnd, HCURSOR hcursor, BOOL use_hcursor)
 {
     struct wayland_pointer *pointer = &process_wayland.pointer;
     struct wayland_surface *surface;
+    struct wayland_win_data *data;
     double scale;
     BOOL reapply_clip = FALSE;
 
-    if ((surface = wayland_surface_lock_hwnd(hwnd)))
+    if ((data = wayland_win_data_get(hwnd)))
     {
+        if (!(surface = data->wayland_surface))
+        {
+            wayland_win_data_release(data);
+            return;
+        }
         scale = surface->window.scale;
         if (use_hcursor) surface->hcursor = hcursor;
         else hcursor = surface->hcursor;
         use_hcursor = TRUE;
-        pthread_mutex_unlock(&surface->mutex);
+        wayland_win_data_release(data);
     }
     else
     {
@@ -859,22 +872,24 @@ BOOL WAYLAND_ClipCursor(const RECT *clip, BOOL reset)
     struct wayland_pointer *pointer = &process_wayland.pointer;
     struct wl_surface *wl_surface = NULL;
     struct wayland_surface *surface = NULL;
+    struct wayland_win_data *data;
     BOOL covers_vscreen = FALSE;
     RECT confine_rect;
 
     TRACE("clip=%s reset=%d\n", wine_dbgstr_rect(clip), reset);
 
-    if ((surface = wayland_surface_lock_hwnd(NtUserGetForegroundWindow())))
+    if (!(data = wayland_win_data_get(NtUserGetForegroundWindow()))) return FALSE;
+    if ((surface = data->wayland_surface))
     {
         wl_surface = surface->wl_surface;
         if (clip) wayland_surface_calc_confine(surface, clip, &confine_rect);
         covers_vscreen = wayland_surface_client_covers_vscreen(surface);
-        pthread_mutex_unlock(&surface->mutex);
     }
+    wayland_win_data_release(data);
 
    /* Since we are running in the context of the foreground thread we know
     * that the wl_surface of the foreground HWND will not be invalidated,
-    * so we can access it without having the surface lock. */
+    * so we can access it without having the win data lock. */
     pthread_mutex_lock(&pointer->mutex);
     wayland_pointer_update_constraint(wl_surface,
                                       (clip && wl_surface) ? &confine_rect : NULL,
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 79b73f24f6c..cfd8b3c9368 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -34,20 +34,21 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
-static void xdg_surface_handle_configure(void *data, struct xdg_surface *xdg_surface,
+static void xdg_surface_handle_configure(void *private, struct xdg_surface *xdg_surface,
                                          uint32_t serial)
 {
     struct wayland_surface *surface;
     BOOL should_post = FALSE, initial_configure = FALSE;
-    HWND hwnd = data;
+    struct wayland_win_data *data;
+    HWND hwnd = private;
 
     TRACE("serial=%u\n", serial);
 
-    if (!(surface = wayland_surface_lock_hwnd(hwnd))) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
 
     /* Handle this event only if wayland_surface is still associated with
      * the target xdg_surface. */
-    if (surface->xdg_surface == xdg_surface)
+    if ((surface = data->wayland_surface) && surface->xdg_surface == xdg_surface)
     {
         /* If we have a previously requested config, we have already sent a
          * WM_WAYLAND_CONFIGURE which hasn't been handled yet. In that case,
@@ -59,7 +60,7 @@ static void xdg_surface_handle_configure(void *data, struct xdg_surface *xdg_sur
         memset(&surface->pending, 0, sizeof(surface->pending));
     }
 
-    pthread_mutex_unlock(&surface->mutex);
+    wayland_win_data_release(data);
 
     if (should_post) NtUserPostMessage(hwnd, WM_WAYLAND_CONFIGURE, 0, 0);
 
@@ -76,15 +77,16 @@ static const struct xdg_surface_listener xdg_surface_listener =
     xdg_surface_handle_configure
 };
 
-static void xdg_toplevel_handle_configure(void *data,
+static void xdg_toplevel_handle_configure(void *private,
                                           struct xdg_toplevel *xdg_toplevel,
                                           int32_t width, int32_t height,
                                           struct wl_array *states)
 {
     struct wayland_surface *surface;
-    HWND hwnd = data;
+    HWND hwnd = private;
     uint32_t *state;
     enum wayland_surface_config_state config_state = 0;
+    struct wayland_win_data *data;
 
     wl_array_for_each(state, states)
     {
@@ -112,16 +114,16 @@ static void xdg_toplevel_handle_configure(void *data,
 
     TRACE("hwnd=%p %dx%d,%#x\n", hwnd, width, height, config_state);
 
-    if (!(surface = wayland_surface_lock_hwnd(hwnd))) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if (surface->xdg_toplevel == xdg_toplevel)
+    if ((surface = data->wayland_surface) && surface->xdg_toplevel == xdg_toplevel)
     {
         surface->pending.width = width;
         surface->pending.height = height;
         surface->pending.state = config_state;
     }
 
-    pthread_mutex_unlock(&surface->mutex);
+    wayland_win_data_release(data);
 }
 
 static void xdg_toplevel_handle_close(void *data, struct xdg_toplevel *xdg_toplevel)
@@ -153,8 +155,6 @@ struct wayland_surface *wayland_surface_create(HWND hwnd)
 
     TRACE("surface=%p\n", surface);
 
-    pthread_mutex_init(&surface->mutex, NULL);
-
     surface->hwnd = hwnd;
     surface->wl_surface = wl_compositor_create_surface(process_wayland.wl_compositor);
     if (!surface->wl_surface)
@@ -204,8 +204,6 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         process_wayland.keyboard.focused_hwnd = NULL;
     pthread_mutex_unlock(&process_wayland.keyboard.mutex);
 
-    pthread_mutex_lock(&surface->mutex);
-
     if (surface->wp_viewport)
     {
         wp_viewport_destroy(surface->wp_viewport);
@@ -230,12 +228,8 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         surface->wl_surface = NULL;
     }
 
-    pthread_mutex_unlock(&surface->mutex);
-
     wl_display_flush(process_wayland.wl_display);
 
-    pthread_mutex_destroy(&surface->mutex);
-
     free(surface);
 }
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c1b647435ab..4551540e0d4 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -196,7 +196,6 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wp_viewport *wp_viewport;
-    pthread_mutex_t mutex;
     struct wayland_surface_config pending, requested, processing, current;
     BOOL resizing;
     struct wayland_window_config window;
@@ -242,7 +241,6 @@ void wayland_surface_clear_role(struct wayland_surface *surface);
 void wayland_surface_attach_shm(struct wayland_surface *surface,
                                 struct wayland_shm_buffer *shm_buffer,
                                 HRGN surface_damage_region);
-struct wayland_surface *wayland_surface_lock_hwnd(HWND hwnd);
 BOOL wayland_surface_reconfigure(struct wayland_surface *surface);
 BOOL wayland_surface_config_is_compatible(struct wayland_surface_config *conf,
                                           int width, int height,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 4a621115c03..942d56870a3 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -216,8 +216,6 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
     visible = (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE) == WS_VISIBLE;
     xdg_visible = surface->xdg_toplevel != NULL;
 
-    pthread_mutex_lock(&surface->mutex);
-
     if (visible != xdg_visible)
     {
         /* If we have a pre-existing surface ensure it has no role. */
@@ -239,8 +237,6 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
 
     wayland_win_data_get_config(data, &surface->window);
 
-    pthread_mutex_unlock(&surface->mutex);
-
     /* Size/position changes affect the effective pointer constraint, so update
      * it as needed. */
     if (data->hwnd == NtUserGetForegroundWindow()) reapply_cursor_clipping();
@@ -255,8 +251,6 @@ static void wayland_win_data_update_wayland_state(struct wayland_win_data *data)
     struct wayland_surface *surface = data->wayland_surface;
     BOOL processing_config;
 
-    pthread_mutex_lock(&surface->mutex);
-
     if (!surface->xdg_toplevel) goto out;
 
     processing_config = surface->processing.serial &&
@@ -301,7 +295,6 @@ static void wayland_win_data_update_wayland_state(struct wayland_win_data *data)
     }
 
 out:
-    pthread_mutex_unlock(&surface->mutex);
     wl_display_flush(process_wayland.wl_display);
 }
 
@@ -466,20 +459,26 @@ static void wayland_configure_window(HWND hwnd)
     DWORD style;
     BOOL needs_enter_size_move = FALSE;
     BOOL needs_exit_size_move = FALSE;
+    struct wayland_win_data *data;
 
-    if (!(surface = wayland_surface_lock_hwnd(hwnd))) return;
+    if (!(data = wayland_win_data_get(hwnd))) return;
+    if (!(surface = data->wayland_surface))
+    {
+        wayland_win_data_release(data);
+        return;
+    }
 
     if (!surface->xdg_toplevel)
     {
         TRACE("missing xdg_toplevel, returning\n");
-        pthread_mutex_unlock(&surface->mutex);
+        wayland_win_data_release(data);
         return;
     }
 
     if (!surface->requested.serial)
     {
         TRACE("requested configure event already handled, returning\n");
-        pthread_mutex_unlock(&surface->mutex);
+        wayland_win_data_release(data);
         return;
     }
 
@@ -541,7 +540,7 @@ static void wayland_configure_window(HWND hwnd)
     wayland_surface_coords_to_window(surface, width, height,
                                      &window_width, &window_height);
 
-    pthread_mutex_unlock(&surface->mutex);
+    wayland_win_data_release(data);
 
     TRACE("processing=%dx%d,%#x\n", width, height, state);
 
@@ -620,14 +619,16 @@ static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
  */
 void WAYLAND_SetWindowText(HWND hwnd, LPCWSTR text)
 {
-    struct wayland_surface *surface = wayland_surface_lock_hwnd(hwnd);
+    struct wayland_surface *surface;
+    struct wayland_win_data *data;
 
     TRACE("hwnd=%p text=%s\n", hwnd, wine_dbgstr_w(text));
 
-    if (surface)
+    if ((data = wayland_win_data_get(hwnd)))
     {
-        if (surface->xdg_toplevel) wayland_surface_set_title(surface, text);
-        pthread_mutex_unlock(&surface->mutex);
+        if ((surface = data->wayland_surface) && surface->xdg_toplevel)
+            wayland_surface_set_title(surface, text);
+        wayland_win_data_release(data);
     }
 }
 
@@ -641,6 +642,7 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
     uint32_t button_serial;
     struct wl_seat *wl_seat;
     struct wayland_surface *surface;
+    struct wayland_win_data *data;
 
     TRACE("cmd=%lx hwnd=%p, %lx, %lx\n",
           (long)command, hwnd, (long)wparam, lparam);
@@ -654,11 +656,11 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
 
     if (command == SC_MOVE || command == SC_SIZE)
     {
-        if ((surface = wayland_surface_lock_hwnd(hwnd)))
+        if ((data = wayland_win_data_get(hwnd)))
         {
             pthread_mutex_lock(&process_wayland.seat.mutex);
             wl_seat = process_wayland.seat.wl_seat;
-            if (wl_seat && surface->xdg_toplevel && button_serial)
+            if (wl_seat && (surface = data->wayland_surface) && surface->xdg_toplevel && button_serial)
             {
                 if (command == SC_MOVE)
                 {
@@ -671,7 +673,7 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
                 }
             }
             pthread_mutex_unlock(&process_wayland.seat.mutex);
-            pthread_mutex_unlock(&surface->mutex);
+            wayland_win_data_release(data);
             ret = 0;
         }
     }
@@ -680,23 +682,6 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
     return ret;
 }
 
-/**********************************************************************
- *           wayland_surface_lock_hwnd
- */
-struct wayland_surface *wayland_surface_lock_hwnd(HWND hwnd)
-{
-    struct wayland_win_data *data = wayland_win_data_get(hwnd);
-    struct wayland_surface *surface;
-
-    if (!data) return NULL;
-
-    if ((surface = data->wayland_surface)) pthread_mutex_lock(&surface->mutex);
-
-    wayland_win_data_release(data);
-
-    return surface;
-}
-
 BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffer, HRGN damage_region)
 {
     struct wayland_surface *wayland_surface;
@@ -707,8 +692,6 @@ BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffe
 
     if ((wayland_surface = data->wayland_surface))
     {
-        pthread_mutex_lock(&wayland_surface->mutex);
-
         if (wayland_surface_reconfigure(wayland_surface))
         {
             wayland_surface_attach_shm(wayland_surface, shm_buffer, damage_region);
@@ -719,8 +702,6 @@ BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffe
         {
             TRACE("Wayland surface not configured yet, not flushing\n");
         }
-
-        pthread_mutex_unlock(&wayland_surface->mutex);
     }
 
     /* Update the latest window buffer for the wayland surface. Note that we
@@ -750,8 +731,11 @@ struct wayland_shm_buffer *get_window_surface_contents(HWND hwnd)
 void ensure_window_surface_contents(HWND hwnd)
 {
     struct wayland_surface *wayland_surface;
+    struct wayland_win_data *data;
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
 
-    if ((wayland_surface = wayland_surface_lock_hwnd(hwnd)))
+    if ((wayland_surface = data->wayland_surface))
     {
         wayland_surface_ensure_contents(wayland_surface);
 
@@ -763,7 +747,7 @@ void ensure_window_surface_contents(HWND hwnd)
         {
             wl_surface_commit(wayland_surface->wl_surface);
         }
-
-        pthread_mutex_unlock(&wayland_surface->mutex);
     }
+
+    wayland_win_data_release(data);
 }
-- 
2.46.0

