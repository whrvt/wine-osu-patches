From a155bcfd2579a5c19e93de5dde64a5e38648892d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 20 Aug 2024 15:45:26 +0200
Subject: [PATCH 06/10] winewayland: Move window contents buffer to
 wayland_win_data struct.

---
 dlls/winewayland.drv/wayland_surface.c |  3 ---
 dlls/winewayland.drv/waylanddrv.h      |  3 ++-
 dlls/winewayland.drv/window.c          | 32 ++++++++++++++++----------
 3 files changed, 22 insertions(+), 16 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 040a07463a0..146c688ef4c 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -232,9 +232,6 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     pthread_mutex_unlock(&surface->mutex);
 
-    if (surface->latest_window_buffer)
-        wayland_shm_buffer_unref(surface->latest_window_buffer);
-
     wl_display_flush(process_wayland.wl_display);
 
     pthread_mutex_destroy(&surface->mutex);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 35c18ffe468..5644045109c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -198,7 +198,6 @@ struct wayland_surface
     struct wp_viewport *wp_viewport;
     pthread_mutex_t mutex;
     struct wayland_surface_config pending, requested, processing, current;
-    struct wayland_shm_buffer *latest_window_buffer;
     BOOL resizing;
     struct wayland_window_config window;
     struct wayland_client_surface *client;
@@ -285,6 +284,8 @@ struct wayland_win_data
     struct rb_entry entry;
     /* hwnd that this private data belongs to */
     HWND hwnd;
+    /* last buffer that was set as window contents */
+    struct wayland_shm_buffer *window_contents;
     /* wayland surface (if any) for this window */
     struct wayland_surface *wayland_surface;
     /* wine window_surface backing this window */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ce755de6b9e..a4446b34c56 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -125,6 +125,7 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
         window_surface_release(data->window_surface);
     }
     if (data->wayland_surface) wayland_surface_destroy(data->wayland_surface);
+    if (data->window_contents) wayland_shm_buffer_unref(data->window_contents);
     free(data);
 }
 
@@ -714,10 +715,15 @@ struct wayland_surface *wayland_surface_lock_hwnd(HWND hwnd)
 BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffer, HRGN damage_region)
 {
     struct wayland_surface *wayland_surface;
+    struct wayland_win_data *data;
     BOOL committed = FALSE;
 
-    if ((wayland_surface = wayland_surface_lock_hwnd(hwnd)))
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
+
+    if ((wayland_surface = data->wayland_surface))
     {
+        pthread_mutex_lock(&wayland_surface->mutex);
+
         if (wayland_surface_reconfigure(wayland_surface))
         {
             wayland_surface_attach_shm(wayland_surface, shm_buffer, damage_region);
@@ -729,27 +735,29 @@ BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffe
             TRACE("Wayland surface not configured yet, not flushing\n");
         }
 
-        /* Update the latest window buffer for the wayland surface. Note that we
-         * only care whether the buffer contains the latest window contents,
-         * it's irrelevant if it was actually committed or not. */
-        if (wayland_surface->latest_window_buffer)
-            wayland_shm_buffer_unref(wayland_surface->latest_window_buffer);
-        wayland_shm_buffer_ref((wayland_surface->latest_window_buffer = shm_buffer));
-
         pthread_mutex_unlock(&wayland_surface->mutex);
     }
 
+    /* Update the latest window buffer for the wayland surface. Note that we
+     * only care whether the buffer contains the latest window contents,
+     * it's irrelevant if it was actually committed or not. */
+    if (data->window_contents)
+        wayland_shm_buffer_unref(data->window_contents);
+    wayland_shm_buffer_ref((data->window_contents = shm_buffer));
+
+    wayland_win_data_release(data);
+
     return committed;
 }
 
 struct wayland_shm_buffer *get_window_surface_contents(HWND hwnd)
 {
-    struct wayland_surface *wayland_surface;
     struct wayland_shm_buffer *shm_buffer;
+    struct wayland_win_data *data;
 
-    if (!(wayland_surface = wayland_surface_lock_hwnd(hwnd))) return NULL;
-    if ((shm_buffer = wayland_surface->latest_window_buffer)) wayland_shm_buffer_ref(shm_buffer);
-    pthread_mutex_unlock(&wayland_surface->mutex);
+    if (!(data = wayland_win_data_get(hwnd))) return NULL;
+    if ((shm_buffer = data->window_contents)) wayland_shm_buffer_ref(shm_buffer);
+    wayland_win_data_release(data);
 
     return shm_buffer;
 }
-- 
2.46.0

