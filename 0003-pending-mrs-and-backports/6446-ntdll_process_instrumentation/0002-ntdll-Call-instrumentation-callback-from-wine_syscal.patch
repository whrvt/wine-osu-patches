From ffaf31f72de5e71f522a6b3bfdadfab917cb85d0 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Wed, 4 Sep 2024 16:16:00 -0600
Subject: [PATCH 2/5] ntdll: Call instrumentation callback from
 wine_syscall_dispatcher on x64.

---
 dlls/ntdll/tests/exception.c    | 28 ++++++++++++-------------
 dlls/ntdll/unix/process.c       | 11 ++++++++--
 dlls/ntdll/unix/signal_x86_64.c | 36 +++++++++++++++++++++++++++++----
 dlls/ntdll/unix/unix_private.h  |  1 +
 4 files changed, 56 insertions(+), 20 deletions(-)

diff --git a/dlls/ntdll/tests/exception.c b/dlls/ntdll/tests/exception.c
index 067a4a83736..6a684fc82a3 100644
--- a/dlls/ntdll/tests/exception.c
+++ b/dlls/ntdll/tests/exception.c
@@ -5558,11 +5558,11 @@ static void test_instrumentation_callback(void)
     status = NtQueryInformationProcess( GetCurrentProcess(), ProcessInstrumentationCallback, &info, sizeof(info), NULL );
     data = curr_data;
     ok( status == STATUS_INVALID_INFO_CLASS, "got %#lx.\n", status );
-    todo_wine ok( data.call_count == 1, "got %u.\n", data.call_count );
-    todo_wine ok( data.call_data[0].r10 >= (char *)NtQueryInformationProcess
+    ok( data.call_count == 1, "got %u.\n", data.call_count );
+    ok( data.call_data[0].r10 >= (char *)NtQueryInformationProcess
         && data.call_data[0].r10 < (char *)NtQueryInformationProcess + 0x20,
         "got %p, NtQueryInformationProcess %p.\n", data.call_data[0].r10, NtQueryInformationProcess );
-    todo_wine ok( data.call_data[0].rcx != data.call_data[0].r10, "got %p.\n", data.call_data[0].rcx );
+    ok( data.call_data[0].rcx != data.call_data[0].r10, "got %p.\n", data.call_data[0].rcx );
 
     memset(&info, 0, sizeof(info));
     info.Callback = code_mem;
@@ -5570,7 +5570,7 @@ static void test_instrumentation_callback(void)
     status = NtSetInformationProcess( GetCurrentProcess(), ProcessInstrumentationCallback, &info, sizeof(info) );
     data = curr_data;
     ok( status == STATUS_SUCCESS, "got %#lx.\n", status );
-    todo_wine ok( data.call_count == 1, "got %u.\n", data.call_count );
+    ok( data.call_count == 1, "got %u.\n", data.call_count );
 
     vectored_handler = AddVectoredExceptionHandler( TRUE, test_instrumentation_callback_handler );
     ok( !!vectored_handler, "failed.\n" );
@@ -5595,8 +5595,8 @@ static void test_instrumentation_callback(void)
     else if (pass == 3)
     {
         data = curr_data;
-        todo_wine ok( data.call_count == 1 || broken( data.call_count == 2 ) /* before Win10 1809 */, "got %u.\n", data.call_count );
-        todo_wine ok( data.call_data[0].r10 == pKiUserExceptionDispatcher, "got %p, expected %p.\n", data.call_data[0].r10,
+        ok( data.call_count == 1 || broken( data.call_count == 2 ) /* before Win10 1809 */, "got %u.\n", data.call_count );
+        ok( data.call_data[0].r10 == pKiUserExceptionDispatcher, "got %p, expected %p.\n", data.call_data[0].r10,
             pKiUserExceptionDispatcher );
         init_instrumentation_data( &curr_data );
         NtContinue( &ctx, FALSE );
@@ -5614,8 +5614,8 @@ static void test_instrumentation_callback(void)
     else if (pass == 5)
     {
         data = curr_data;
-        todo_wine ok( data.call_count == 1, "got %u.\n", data.call_count );
-        todo_wine ok( data.call_data[0].r10 == (void *)ctx.Rip, "got %p, expected %p.\n", data.call_data[0].r10, (void *)ctx.Rip );
+        ok( data.call_count == 1, "got %u.\n", data.call_count );
+        ok( data.call_data[0].r10 == (void *)ctx.Rip, "got %p, expected %p.\n", data.call_data[0].r10, (void *)ctx.Rip );
         init_instrumentation_data( &curr_data );
     }
     ok( pass == 5, "got %ld.\n", pass );
@@ -5628,8 +5628,8 @@ static void test_instrumentation_callback(void)
     SleepEx( 0, TRUE );
     data = curr_data;
     ok( apc_called, "APC was not called.\n" );
-    todo_wine ok( data.call_count == 1, "got %u.\n", data.call_count );
-    todo_wine ok( data.call_data[0].r10 == pKiUserApcDispatcher, "got %p, expected %p.\n", data.call_data[0].r10, pKiUserApcDispatcher );
+    ok( data.call_count == 1, "got %u.\n", data.call_count );
+    ok( data.call_data[0].r10 == pKiUserApcDispatcher, "got %p, expected %p.\n", data.call_data[0].r10, pKiUserApcDispatcher );
 
     instrumentation_callback_thread_ready = CreateEventW( NULL, FALSE, FALSE, NULL );
     instrumentation_callback_thread_wait = CreateEventW( NULL, FALSE, FALSE, NULL );
@@ -5637,7 +5637,7 @@ static void test_instrumentation_callback(void)
     thread = CreateThread( NULL, 0, test_instrumentation_callback_thread, 0, 0, NULL );
     NtWaitForSingleObject( instrumentation_callback_thread_ready, FALSE, NULL );
     data = curr_data;
-    todo_wine ok( data.call_count && data.call_count <= 256, "got %u.\n", data.call_count );
+    ok( data.call_count && data.call_count <= 256, "got %u.\n", data.call_count );
     pLdrInitializeThunk = GetProcAddress( ntdll, "LdrInitializeThunk" );
     for (i = 0; i < data.call_count; ++i)
     {
@@ -5649,14 +5649,14 @@ static void test_instrumentation_callback(void)
     SetEvent( instrumentation_callback_thread_wait );
     NtWaitForSingleObject( instrumentation_callback_thread_ready, FALSE, NULL );
     data = curr_data;
-    todo_wine ok( data.call_count && data.call_count <= 256, "got %u.\n", data.call_count );
+    ok( data.call_count && data.call_count <= 256, "got %u.\n", data.call_count );
     count = 0;
     for (i = 0; i < data.call_count; ++i)
     {
         if (data.call_data[i].r10 >= (char *)NtWaitForSingleObject && data.call_data[i].r10 < (char *)NtWaitForSingleObject + 0x20)
             ++count;
     }
-    todo_wine ok( count == 2, "got %u.\n", count );
+    ok( count == 2, "got %u.\n", count );
 
     SetEvent( instrumentation_callback_thread_wait );
     WaitForSingleObject( thread, INFINITE );
@@ -5668,7 +5668,7 @@ static void test_instrumentation_callback(void)
     init_instrumentation_data( &curr_data );
     DestroyWindow( hwnd );
     data = curr_data;
-    todo_wine ok( data.call_count && data.call_count <= 256, "got %u.\n", data.call_count );
+    ok( data.call_count && data.call_count <= 256, "got %u.\n", data.call_count );
     for (i = 0; i < data.call_count; ++i)
     {
         if (data.call_data[i].r10 == pKiUserCallbackDispatcher)
diff --git a/dlls/ntdll/unix/process.c b/dlls/ntdll/unix/process.c
index e00b5ca6ca6..6ec53aaa5b2 100644
--- a/dlls/ntdll/unix/process.c
+++ b/dlls/ntdll/unix/process.c
@@ -78,6 +78,8 @@ static ULONG execute_flags = MEM_EXECUTE_OPTION_DISABLE;
 
 static UINT process_error_mode;
 
+void *instrumentation_callback;
+
 static char **build_argv( const UNICODE_STRING *cmdline, int reserved )
 {
     char **argv, *arg, *src, *dst;
@@ -1712,10 +1714,15 @@ NTSTATUS WINAPI NtSetInformationProcess( HANDLE handle, PROCESSINFOCLASS class,
     {
         PROCESS_INSTRUMENTATION_CALLBACK_INFORMATION *instr = info;
 
-        FIXME( "ProcessInstrumentationCallback stub.\n" );
-
         if (size < sizeof(*instr)) return STATUS_INFO_LENGTH_MISMATCH;
+
         ret = STATUS_SUCCESS;
+        if (handle != GetCurrentProcess())
+        {
+            FIXME( "Setting ProcessInstrumentationCallback not yet supported for other process.\n" );
+            break;
+        }
+        InterlockedExchangePointer( &instrumentation_callback, instr->Callback );
         break;
     }
 
diff --git a/dlls/ntdll/unix/signal_x86_64.c b/dlls/ntdll/unix/signal_x86_64.c
index 1557d7bcb43..c57df9d916e 100644
--- a/dlls/ntdll/unix/signal_x86_64.c
+++ b/dlls/ntdll/unix/signal_x86_64.c
@@ -392,6 +392,8 @@ C_ASSERT( sizeof(struct callback_stack_layout) == 0x58 );
 #define SYSCALL_HAVE_XSAVEC      2
 #define SYSCALL_HAVE_PTHREAD_TEB 4
 #define SYSCALL_HAVE_WRFSGSBASE  8
+#define SYSCALL_INSTRUMENTATION  16 /* set in wine_syscall_dispatcher / wine_syscall_dispatcher_return,
+                                     * never stored in syscall_frame->syscall_flags. */
 
 static unsigned int syscall_flags;
 
@@ -421,7 +423,7 @@ struct syscall_frame
     void                 *syscall_cfa;   /* 00a8 */
     DWORD                 syscall_flags; /* 00b0 */
     DWORD                 restore_flags; /* 00b4 */
-    DWORD                 align[2];      /* 00b8 */
+    void                **instrumentation_callback; /* 00b8 */
     XMM_SAVE_AREA32       xsave;         /* 00c0 */
     DECLSPEC_ALIGN(64) XSAVE_AREA_HEADER xstate;    /* 02c0 */
 };
@@ -1604,6 +1606,8 @@ __ASM_GLOBAL_FUNC( call_user_mode_callback,
                    "movl 0xb0(%r10),%r14d\n\t" /* prev_frame->syscall_flags */
                    "movl %r14d,0xb0(%rsp)\n\t" /* frame->syscall_flags */
                    "movq %r10,0xa0(%rsp)\n\t"  /* frame->prev_frame */
+                   "movq 0xb8(%r10),%r10\n\t"  /* prev_frame->instrumentation_callback */
+                   "movq %r10,0xb8(%rsp)\n\t"  /* frame->instrumentation_callback */
                    "movq %rsp,0x328(%r8)\n\t"  /* amd64_thread_data()->syscall_frame */
                    /* switch to user stack */
                    "movq %rdi,%rsp\n\t"        /* user_rsp */
@@ -2593,6 +2597,7 @@ void call_init_thunk( LPTHREAD_START_ROUTINE entry, void *arg, BOOL suspend, TEB
     frame->restore_flags |= CONTEXT_INTEGER;
     frame->syscall_flags = syscall_flags;
     frame->syscall_cfa   = syscall_cfa;
+    frame->instrumentation_callback = &instrumentation_callback;
 
     pthread_sigmask( SIG_UNBLOCK, &server_block_set, NULL );
     __wine_syscall_dispatcher_return( frame, 0 );
@@ -2679,7 +2684,12 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                     * depends on us returning to it. Adjust the return address accordingly. */
                    "subq $0xb,0x70(%rcx)\n\t"
                    "movl 0xb0(%rcx),%r14d\n\t"     /* frame->syscall_flags */
-                   "testl $3,%r14d\n\t"            /* SYSCALL_HAVE_XSAVE | SYSCALL_HAVE_XSAVEC */
+                   "movq 0xb8(%rcx),%rdx\n\t"      /* frame->instrumentation_callback */
+                   "movq (%rdx),%rdx\n\t"
+                   "test %rdx,%rdx\n\t"
+                   "jz 1f\n\t"
+                   "orl $16,%r14d\n\t"             /* SYSCALL_INSTRUMENTATION */
+                   "1\t:testl $3,%r14d\n\t"        /* SYSCALL_HAVE_XSAVE | SYSCALL_HAVE_XSAVEC */
                    "jz 2f\n\t"
 #ifdef __APPLE__
                    "movq %gs:0x30,%rdx\n\t"
@@ -2832,8 +2842,10 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "movw %gs:0x338,%fs\n"          /* amd64_thread_data()->fs */
                    "1:\n\t"
 #endif
+                   "testl $16,%r14d\n\t"           /* SYSCALL_INSTRUMENTATION */
                    "movq 0x60(%rcx),%r14\n\t"
-                   "testl $0x3,%edx\n\t"           /* CONTEXT_CONTROL | CONTEXT_INTEGER */
+                   "jnz 2f\n\t"
+                   "3:\ttestl $0x3,%edx\n\t"       /* CONTEXT_CONTROL | CONTEXT_INTEGER */
                    "jnz 1f\n\t"
 
                    /* switch to user stack */
@@ -2864,8 +2876,10 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
 
                    "1:\ttestl $0x2,%edx\n\t"       /* CONTEXT_INTEGER */
                    "jnz 1f\n\t"
+                   /* CONTEXT_CONTROL */
                    "movq (%rsp),%rcx\n\t"          /* frame->rip */
                    "iretq\n"
+                   /* CONTEXT_INTEGER */
                    "1:\tmovq 0x00(%rcx),%rax\n\t"
                    "movq 0x18(%rcx),%rdx\n\t"
                    "movq 0x30(%rcx),%r8\n\t"
@@ -2874,6 +2888,15 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
                    "movq 0x48(%rcx),%r11\n\t"
                    "movq 0x10(%rcx),%rcx\n\t"
                    "iretq\n"
+                   /* SYSCALL_INSTRUMENTATION */
+                   "2:\tmovq 0xb8(%rcx),%r10\n\t"
+                   "movq (%r10),%r10\n\t"
+                   "test %r10,%r10\n\t"
+                   "jz 3b\n\t"
+                   "testl $0x2,%edx\n\t"          /* CONTEXT_INTEGER */
+                   "jnz 1b\n\t"
+                   "xchgq %r10,(%rsp)\n\t"
+                   "iretq\n\t"
 
                    /* pop rbp-based kernel stack cfi */
                    __ASM_CFI("\t.cfi_restore_state\n")
@@ -2884,7 +2907,12 @@ __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher,
 __ASM_GLOBAL_FUNC( __wine_syscall_dispatcher_return,
                    "movq %rdi,%rcx\n\t"
                    "movl 0xb0(%rcx),%r14d\n\t"     /* frame->syscall_flags */
-                   "movq %rsi,%rax\n\t"
+                   "movq 0xb8(%rcx),%rdx\n\t"      /* frame->instrumentation_callback */
+                   "movq (%rdx),%rdx\n\t"
+                   "test %rdx,%rdx\n\t"
+                   "jz 1f\n\t"
+                   "orl $16,%r14d\n\t"             /* SYSCALL_INSTRUMENTATION */
+                   "1\t:movq %rsi,%rax\n\t"
                    "jmp " __ASM_LOCAL_LABEL("__wine_syscall_dispatcher_return") )
 
 
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index 8ce45dfa0bc..23305df2080 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -186,6 +186,7 @@ extern SYSTEM_CPU_INFORMATION cpu_info;
 #ifdef __i386__
 extern struct ldt_copy __wine_ldt_copy;
 #endif
+extern void *instrumentation_callback;
 
 extern void init_environment(void);
 extern void init_startup_info(void);
-- 
2.46.0

