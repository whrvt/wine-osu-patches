From fa9e5f95c2e211d36430d3dafa258f149ff003d9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 16 Sep 2024 15:36:49 +0200
Subject: [PATCH] winewayland: Update the client separately from the window
 surface updates.

---
 dlls/winewayland.drv/wayland_surface.c |  7 +++----
 dlls/winewayland.drv/waylanddrv.h      |  4 ++--
 dlls/winewayland.drv/window.c          | 19 ++++++++-----------
 3 files changed, 13 insertions(+), 17 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index d526123b569..4dc3101de76 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -535,7 +535,7 @@ void wayland_surface_reconfigure_client(struct wayland_surface *surface, struct
  * Reconfigures the wayland surface as needed to match the latest requested
  * state.
  */
-BOOL wayland_surface_reconfigure(struct wayland_surface *surface, struct wayland_client_surface *client)
+BOOL wayland_surface_reconfigure(struct wayland_surface *surface)
 {
     struct wayland_window_config *window = &surface->window;
     int win_width, win_height, width, height;
@@ -586,7 +586,6 @@ BOOL wayland_surface_reconfigure(struct wayland_surface *surface, struct wayland
 
     wayland_surface_reconfigure_geometry(surface, width, height);
     wayland_surface_reconfigure_size(surface, width, height);
-    if (client) wayland_surface_reconfigure_client(surface, client);
 
     return TRUE;
 }
@@ -881,7 +880,7 @@ static const struct wl_buffer_listener dummy_buffer_listener =
  * Ensure that the wayland surface has up-to-date contents, by committing
  * a dummy buffer if necessary.
  */
-void wayland_surface_ensure_contents(struct wayland_surface *surface, struct wayland_client_surface *client)
+void wayland_surface_ensure_contents(struct wayland_surface *surface)
 {
     struct wayland_shm_buffer *dummy_shm_buffer;
     HRGN damage;
@@ -912,7 +911,7 @@ void wayland_surface_ensure_contents(struct wayland_surface *surface, struct way
     if (!(damage = NtGdiCreateRectRgn(0, 0, width, height)))
         WARN("Failed to create damage region for dummy buffer\n");
 
-    if (wayland_surface_reconfigure(surface, client))
+    if (wayland_surface_reconfigure(surface))
     {
         wayland_surface_attach_shm(surface, dummy_shm_buffer, damage);
         wl_surface_commit(surface->wl_surface);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 73ab767506a..bd599f2291b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -242,7 +242,7 @@ void wayland_surface_clear_role(struct wayland_surface *surface);
 void wayland_surface_attach_shm(struct wayland_surface *surface,
                                 struct wayland_shm_buffer *shm_buffer,
                                 HRGN surface_damage_region);
-BOOL wayland_surface_reconfigure(struct wayland_surface *surface, struct wayland_client_surface *client);
+BOOL wayland_surface_reconfigure(struct wayland_surface *surface);
 void wayland_surface_reconfigure_client(struct wayland_surface *surface, struct wayland_client_surface *client);
 BOOL wayland_surface_config_is_compatible(struct wayland_surface_config *conf,
                                           int width, int height,
@@ -257,7 +257,7 @@ struct wayland_client_surface *wayland_client_surface_create(HWND hwnd);
 BOOL wayland_client_surface_release(struct wayland_client_surface *client);
 void wayland_client_surface_attach(struct wayland_client_surface *client, HWND toplevel);
 void wayland_client_surface_detach(struct wayland_client_surface *client);
-void wayland_surface_ensure_contents(struct wayland_surface *surface, struct wayland_client_surface *client);
+void wayland_surface_ensure_contents(struct wayland_surface *surface);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 
 /**********************************************************************
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index dda5e00fc29..e6d1761663c 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -228,27 +228,23 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         goto out;
     }
 
+    visible = (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE) == WS_VISIBLE;
+    if (!visible && client) wayland_client_surface_detach(client);
+
     /* Otherwise ensure that we have a wayland surface. */
     if (!surface && !(surface = wayland_surface_create(data->hwnd))) return;
-
-    visible = (NtUserGetWindowLongW(data->hwnd, GWL_STYLE) & WS_VISIBLE) == WS_VISIBLE;
     xdg_visible = surface->xdg_toplevel != NULL;
 
     if (visible != xdg_visible)
     {
         /* If we have a pre-existing surface ensure it has no role. */
-        if (data->wayland_surface)
-        {
-            if (client) wayland_client_surface_detach(client);
-            wayland_surface_clear_role(surface);
-        }
+        if (data->wayland_surface) wayland_surface_clear_role(surface);
         /* If the window is a visible toplevel make it a wayland
          * xdg_toplevel. Otherwise keep it role-less to avoid polluting the
          * compositor with empty xdg_toplevels. */
         if (visible)
         {
             wayland_surface_make_toplevel(surface);
-            if (client) wayland_client_surface_attach(client, data->hwnd);
             if (surface->xdg_toplevel)
             {
                 if (!NtUserInternalGetWindowText(data->hwnd, text, ARRAY_SIZE(text)))
@@ -258,6 +254,7 @@ static void wayland_win_data_update_wayland_surface(struct wayland_win_data *dat
         }
     }
 
+    if (visible && client) wayland_client_surface_attach(client, data->hwnd);
     wayland_win_data_get_config(data, &surface->window);
 
     /* Size/position changes affect the effective pointer constraint, so update
@@ -756,7 +753,7 @@ BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffe
 
     if ((wayland_surface = data->wayland_surface))
     {
-        if (wayland_surface_reconfigure(wayland_surface, data->client_surface))
+        if (wayland_surface_reconfigure(wayland_surface))
         {
             wayland_surface_attach_shm(wayland_surface, shm_buffer, damage_region);
             wl_surface_commit(wayland_surface->wl_surface);
@@ -801,13 +798,13 @@ void ensure_window_surface_contents(HWND hwnd)
 
     if ((wayland_surface = data->wayland_surface))
     {
-        wayland_surface_ensure_contents(wayland_surface, data->client_surface);
+        wayland_surface_ensure_contents(wayland_surface);
 
         /* Handle any processed configure request, to ensure the related
          * surface state is applied by the compositor. */
         if (wayland_surface->processing.serial &&
             wayland_surface->processing.processed &&
-            wayland_surface_reconfigure(wayland_surface, data->client_surface))
+            wayland_surface_reconfigure(wayland_surface))
         {
             wl_surface_commit(wayland_surface->wl_surface);
         }
-- 
GitLab

