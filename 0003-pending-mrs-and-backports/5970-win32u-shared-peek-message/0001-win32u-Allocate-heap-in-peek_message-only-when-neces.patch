From 5c24c0e9053ba9684079c64c5a5c4bce760c792b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 25 Jun 2024 16:43:28 +0200
Subject: [PATCH 1/3] win32u: Allocate heap in peek_message only when
 necessary.

---
 dlls/win32u/message.c | 32 ++++++++++++++++++++------------
 1 file changed, 20 insertions(+), 12 deletions(-)

diff --git a/dlls/win32u/message.c b/dlls/win32u/message.c
index 2f5ffc3a538..0a7102fece2 100644
--- a/dlls/win32u/message.c
+++ b/dlls/win32u/message.c
@@ -2693,10 +2693,9 @@ int peek_message( MSG *msg, const struct peek_message_filter *filter )
     INPUT_MESSAGE_SOURCE prev_source = thread_info->client_info.msg_source;
     struct received_message_info info;
     unsigned int hw_id = 0;  /* id of previous hardware message */
-    void *buffer;
-    size_t buffer_size = 1024;
-
-    if (!(buffer = malloc( buffer_size ))) return -1;
+    unsigned char buffer_init[1024];
+    size_t buffer_size = sizeof(buffer_init);
+    void *buffer = buffer_init;
 
     if (!first && !last) last = ~0;
     if (hwnd == HWND_BROADCAST) hwnd = HWND_TOPMOST;
@@ -2739,11 +2738,8 @@ int peek_message( MSG *msg, const struct peek_message_filter *filter )
 
         if (res)
         {
-            free( buffer );
-            if (res == STATUS_PENDING)
-            {
-                return 0;
-            }
+            if (buffer != buffer_init) free( buffer );
+            if (res == STATUS_PENDING) return 0;
             if (res != STATUS_BUFFER_OVERFLOW)
             {
                 RtlSetLastWin32Error( RtlNtStatusToDosError(res) );
@@ -2766,6 +2762,12 @@ int peek_message( MSG *msg, const struct peek_message_filter *filter )
             break;
         case MSG_NOTIFY:
             info.flags = ISMEX_NOTIFY;
+            /* unpack_message may have to reallocate */
+            if (buffer == buffer_init)
+            {
+                buffer = malloc( buffer_size );
+                memcpy( buffer, buffer_init, buffer_size );
+            }
             if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
                                  &info.msg.lParam, &buffer, size, &buffer_size ))
                 continue;
@@ -2844,6 +2846,12 @@ int peek_message( MSG *msg, const struct peek_message_filter *filter )
             continue;
         case MSG_OTHER_PROCESS:
             info.flags = ISMEX_SEND;
+            /* unpack_message may have to reallocate */
+            if (buffer == buffer_init)
+            {
+                buffer = malloc( buffer_size );
+                memcpy( buffer, buffer_init, buffer_size );
+            }
             if (!unpack_message( info.msg.hwnd, info.msg.message, &info.msg.wParam,
                                  &info.msg.lParam, &buffer, size, &buffer_size ))
             {
@@ -2866,7 +2874,7 @@ int peek_message( MSG *msg, const struct peek_message_filter *filter )
                 thread_info->client_info.message_pos   = MAKELONG( info.msg.pt.x, info.msg.pt.y );
                 thread_info->client_info.message_time  = info.msg.time;
                 thread_info->client_info.message_extra = msg_data->hardware.info;
-                free( buffer );
+                if (buffer != buffer_init) free( buffer );
                 call_hooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, sizeof(*msg) );
                 return 1;
             }
@@ -2881,7 +2889,7 @@ int peek_message( MSG *msg, const struct peek_message_filter *filter )
                     /* if this is a nested call return right away */
                     if (first == info.msg.message && last == info.msg.message)
                     {
-                        free( buffer );
+                        if (buffer != buffer_init) free( buffer );
                         return 0;
                     }
                 }
@@ -2930,7 +2938,7 @@ int peek_message( MSG *msg, const struct peek_message_filter *filter )
             thread_info->client_info.message_time  = info.msg.time;
             thread_info->client_info.message_extra = 0;
             thread_info->client_info.msg_source = msg_source_unavailable;
-            free( buffer );
+            if (buffer != buffer_init) free( buffer );
             call_hooks( WH_GETMESSAGE, HC_ACTION, flags & PM_REMOVE, (LPARAM)msg, sizeof(*msg) );
             return 1;
         }
-- 
2.45.2

