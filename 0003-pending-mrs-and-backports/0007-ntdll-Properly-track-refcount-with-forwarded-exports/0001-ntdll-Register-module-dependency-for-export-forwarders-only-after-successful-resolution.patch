From 554dcfa220b28f08727aae58d01af46f8cb70f5a Mon Sep 17 00:00:00 2001
From: Jinoh Kang <jinoh.kang.kr@gmail.com>
Date: Thu, 13 Feb 2025 06:29:05 +0900
Subject: [PATCH] ntdll: Register module dependency for export forwarders only
 after successful resolution.

---
 dlls/ntdll/loader.c | 48 +++++++++++++++++++++++++++++++--------------
 1 file changed, 33 insertions(+), 15 deletions(-)

diff --git a/dlls/ntdll/loader.c b/dlls/ntdll/loader.c
index 3872f2b237b..04a68116c1e 100644
--- a/dlls/ntdll/loader.c
+++ b/dlls/ntdll/loader.c
@@ -910,6 +910,7 @@ static FARPROC find_forwarded_export( HMODULE module, const char *forward, LPCWS
     WCHAR mod_name[256];
     const char *end = strrchr(forward, '.');
     FARPROC proc = NULL;
+    BOOL wm_owned_ref;
 
     if (!end) return NULL;
     if (build_import_name( importer, mod_name, forward, end - forward )) return NULL;
@@ -918,27 +919,22 @@ static FARPROC find_forwarded_export( HMODULE module, const char *forward, LPCWS
     {
         WINE_MODREF *imp = get_modref( module );
         TRACE( "delay loading %s for '%s'\n", debugstr_w(mod_name), forward );
-        if (load_dll( load_path, mod_name, 0, &wm, imp->system ) == STATUS_SUCCESS &&
-            !(wm->ldr.Flags & LDR_DONT_RESOLVE_REFS))
-        {
-            if (!imports_fixup_done && importer)
-            {
-                add_module_dependency( importer->ldr.DdagNode, wm->ldr.DdagNode );
-            }
-            else if (process_attach( wm->ldr.DdagNode, NULL ) != STATUS_SUCCESS)
-            {
-                LdrUnloadDll( wm->ldr.DllBase );
-                wm = NULL;
-            }
-        }
-
-        if (!wm)
+        if (load_dll( load_path, mod_name, 0, &wm, imp->system ) != STATUS_SUCCESS)
         {
             ERR( "module not found for forward '%s' used by %s\n",
                  forward, debugstr_w(imp->ldr.FullDllName.Buffer) );
             return NULL;
         }
+
+        /* load_dll() returns a new (owned) reference */
+        wm_owned_ref = TRUE;
     }
+    else
+    {
+        /* find_basename_module() returns a borrowed reference */
+        wm_owned_ref = FALSE;
+    }
+
     if ((exports = RtlImageDirectoryEntryToData( wm->ldr.DllBase, TRUE,
                                                  IMAGE_DIRECTORY_ENTRY_EXPORT, &exp_size )))
     {
@@ -958,6 +954,28 @@ static FARPROC find_forwarded_export( HMODULE module, const char *forward, LPCWS
             forward, debugstr_w(get_modref(module)->ldr.FullDllName.Buffer),
             debugstr_w(get_modref(module)->ldr.BaseDllName.Buffer) );
     }
+    else
+    {
+        if (wm_owned_ref && !(wm->ldr.Flags & LDR_DONT_RESOLVE_REFS))
+        {
+            if (!imports_fixup_done && importer)
+            {
+                /* Prepare for the callee stealing the reference */
+                wm_owned_ref = FALSE;
+                add_module_dependency( importer->ldr.DdagNode, wm->ldr.DdagNode );
+            }
+            else if (process_attach( wm->ldr.DdagNode, NULL ) != STATUS_SUCCESS)
+            {
+                proc = NULL;
+            }
+        }
+        if (proc && wm_owned_ref)
+        {
+            /* Owned, but no way to bind to a dependency; leak the reference instead */
+            wm_owned_ref = FALSE;
+        }
+    }
+    if (wm_owned_ref) LdrUnloadDll( wm->ldr.DllBase );
     return proc;
 }
 
-- 
GitLab

