From f157f722643756cc464234f42adc6d260b45494b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Sep 2024 10:27:27 +0200
Subject: [PATCH 4/5] winewayland: Move client surface to wayland_win_data
 struct.

---
 dlls/winewayland.drv/opengl.c          |  4 ++--
 dlls/winewayland.drv/vulkan.c          |  4 ++--
 dlls/winewayland.drv/wayland_surface.c | 26 ++++++++++++--------------
 dlls/winewayland.drv/waylanddrv.h      | 10 ++++++----
 dlls/winewayland.drv/window.c          | 24 ++++++++++++------------
 5 files changed, 34 insertions(+), 34 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 74c3cb02d8e..ecb1a65c38c 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -168,8 +168,8 @@ static void wayland_gl_drawable_release(struct wayland_gl_drawable *gl)
         HWND hwnd = wl_surface_get_user_data(gl->client->wl_surface);
         struct wayland_win_data *data = wayland_win_data_get(hwnd);
 
-        if (wayland_client_surface_release(gl->client) && data && data->wayland_surface)
-            data->wayland_surface->client = NULL;
+        if (wayland_client_surface_release(gl->client) && data)
+            data->client_surface = NULL;
 
         if (data) wayland_win_data_release(data);
     }
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 9628fd81fe5..7c8537bfc40 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -63,8 +63,8 @@ static void wine_vk_surface_destroy(struct wayland_client_surface *client)
     HWND hwnd = wl_surface_get_user_data(client->wl_surface);
     struct wayland_win_data *data = wayland_win_data_get(hwnd);
 
-    if (wayland_client_surface_release(client) && data && data->wayland_surface)
-        data->wayland_surface->client = NULL;
+    if (wayland_client_surface_release(client) && data)
+        data->client_surface = NULL;
 
     if (data) wayland_win_data_release(data);
 }
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5d3fe1e3938..27d1fde8c12 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -494,14 +494,12 @@ static void wayland_surface_reconfigure_size(struct wayland_surface *surface,
  *
  * Reconfigures the subsurface covering the client area.
  */
-void wayland_surface_reconfigure_client(struct wayland_surface *surface)
+void wayland_surface_reconfigure_client(struct wayland_surface *surface, struct wayland_client_surface *client)
 {
     struct wayland_window_config *window = &surface->window;
     int client_x, client_y, x, y;
     int client_width, client_height, width, height;
 
-    if (!surface->client) return;
-
     /* The offset of the client area origin relatively to the window origin. */
     client_x = window->client_rect.left - window->rect.left;
     client_y = window->client_rect.top - window->rect.top;
@@ -515,17 +513,16 @@ void wayland_surface_reconfigure_client(struct wayland_surface *surface)
 
     TRACE("hwnd=%p subsurface=%d,%d+%dx%d\n", surface->hwnd, x, y, width, height);
 
-    wl_subsurface_set_position(surface->client->wl_subsurface, x, y);
+    wl_subsurface_set_position(client->wl_subsurface, x, y);
 
     if (width != 0 && height != 0)
-        wp_viewport_set_destination(surface->client->wp_viewport,
-                                    width, height);
+        wp_viewport_set_destination(client->wp_viewport, width, height);
     else /* We can't have a 0x0 destination, use 1x1 instead. */
-        wp_viewport_set_destination(surface->client->wp_viewport, 1, 1);
+        wp_viewport_set_destination(client->wp_viewport, 1, 1);
 
-    wl_surface_commit(surface->client->wl_surface);
+    wl_surface_commit(client->wl_surface);
 
-    wayland_resize_gl_drawable(surface->hwnd);
+    wayland_resize_gl_drawable(client->hwnd);
 }
 
 /**********************************************************************
@@ -534,7 +531,7 @@ void wayland_surface_reconfigure_client(struct wayland_surface *surface)
  * Reconfigures the wayland surface as needed to match the latest requested
  * state.
  */
-BOOL wayland_surface_reconfigure(struct wayland_surface *surface)
+BOOL wayland_surface_reconfigure(struct wayland_surface *surface, struct wayland_client_surface *client)
 {
     struct wayland_window_config *window = &surface->window;
     int win_width, win_height, width, height;
@@ -585,7 +582,7 @@ BOOL wayland_surface_reconfigure(struct wayland_surface *surface)
 
     wayland_surface_reconfigure_geometry(surface, width, height);
     wayland_surface_reconfigure_size(surface, width, height);
-    wayland_surface_reconfigure_client(surface);
+    if (client) wayland_surface_reconfigure_client(surface, client);
 
     return TRUE;
 }
@@ -779,6 +776,7 @@ struct wayland_client_surface *wayland_client_surface_create(HWND hwnd)
         return NULL;
     }
     client->ref = 1;
+    client->hwnd = hwnd;
 
     client->wl_surface =
         wl_compositor_create_surface(process_wayland.wl_compositor);
@@ -829,7 +827,7 @@ void wayland_client_surface_attach(struct wayland_client_surface *client, struct
     /* Present contents independently of the parent surface. */
     wl_subsurface_set_desync(client->wl_subsurface);
 
-    wayland_surface_reconfigure_client(surface);
+    wayland_surface_reconfigure_client(surface, client);
     /* Commit to apply subsurface positioning. */
     wl_surface_commit(surface->wl_surface);
 }
@@ -852,7 +850,7 @@ static const struct wl_buffer_listener dummy_buffer_listener =
  * Ensure that the wayland surface has up-to-date contents, by committing
  * a dummy buffer if necessary.
  */
-void wayland_surface_ensure_contents(struct wayland_surface *surface)
+void wayland_surface_ensure_contents(struct wayland_surface *surface, struct wayland_client_surface *client)
 {
     struct wayland_shm_buffer *dummy_shm_buffer;
     HRGN damage;
@@ -883,7 +881,7 @@ void wayland_surface_ensure_contents(struct wayland_surface *surface)
     if (!(damage = NtGdiCreateRectRgn(0, 0, width, height)))
         WARN("Failed to create damage region for dummy buffer\n");
 
-    if (wayland_surface_reconfigure(surface))
+    if (wayland_surface_reconfigure(surface, client))
     {
         wayland_surface_attach_shm(surface, dummy_shm_buffer, damage);
         wl_surface_commit(surface->wl_surface);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8e1895b9b8d..ecefeeb77af 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -184,6 +184,7 @@ struct wayland_window_config
 struct wayland_client_surface
 {
     LONG ref;
+    HWND hwnd;
     struct wl_surface *wl_surface;
     struct wl_subsurface *wl_subsurface;
     struct wp_viewport *wp_viewport;
@@ -199,7 +200,6 @@ struct wayland_surface
     struct wayland_surface_config pending, requested, processing, current;
     BOOL resizing;
     struct wayland_window_config window;
-    struct wayland_client_surface *client;
     int content_width, content_height;
     HCURSOR hcursor;
 };
@@ -241,8 +241,8 @@ void wayland_surface_clear_role(struct wayland_surface *surface);
 void wayland_surface_attach_shm(struct wayland_surface *surface,
                                 struct wayland_shm_buffer *shm_buffer,
                                 HRGN surface_damage_region);
-void wayland_surface_reconfigure_client(struct wayland_surface *surface);
-BOOL wayland_surface_reconfigure(struct wayland_surface *surface);
+BOOL wayland_surface_reconfigure(struct wayland_surface *surface, struct wayland_client_surface *client);
+void wayland_surface_reconfigure_client(struct wayland_surface *surface, struct wayland_client_surface *client);
 BOOL wayland_surface_config_is_compatible(struct wayland_surface_config *conf,
                                           int width, int height,
                                           enum wayland_surface_config_state state);
@@ -255,7 +255,7 @@ void wayland_surface_coords_to_window(struct wayland_surface *surface,
 struct wayland_client_surface *wayland_client_surface_create(HWND hwnd);
 BOOL wayland_client_surface_release(struct wayland_client_surface *client);
 void wayland_client_surface_attach(struct wayland_client_surface *client, struct wayland_surface *surface);
-void wayland_surface_ensure_contents(struct wayland_surface *surface);
+void wayland_surface_ensure_contents(struct wayland_surface *surface, struct wayland_client_surface *client);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
 
 /**********************************************************************
@@ -281,6 +281,8 @@ struct wayland_win_data
     struct wayland_shm_buffer *window_contents;
     /* wayland surface (if any) for this window */
     struct wayland_surface *wayland_surface;
+    /* wayland client surface (if any) for this window */
+    struct wayland_client_surface *client_surface;
     /* window rects, relative to parent client area */
     struct window_rects rects;
     BOOL managed;
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 2b6576cb4a4..a839c14d537 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -691,18 +691,18 @@ struct wayland_client_surface *get_client_surface(HWND hwnd, RECT *client_rect)
     struct wayland_surface *surface;
     struct wayland_win_data *data;
 
-    if (!(data = wayland_win_data_get(hwnd))) surface = NULL;
-    else surface = data->wayland_surface;
-
-    if (surface)
+    if ((data = wayland_win_data_get(hwnd)))
     {
-        *client_rect = surface->window.client_rect;
-        client = surface->client;
+        *client_rect = data->wayland_surface ? data->wayland_surface->window.client_rect
+                                             : data->rects.client;
+        client = data->client_surface;
+        surface = data->wayland_surface;
     }
     else
     {
         SetRectEmpty(client_rect);
         client = NULL;
+        surface = NULL;
     }
 
     if (!client && !(client = wayland_client_surface_create(hwnd)))
@@ -712,11 +712,11 @@ struct wayland_client_surface *get_client_surface(HWND hwnd, RECT *client_rect)
     }
     if (!data) return client;
 
-    if (surface && !surface->client)
+    if (!data->client_surface)
     {
-        wayland_client_surface_attach(client, surface);
+        if (surface) wayland_client_surface_attach(client, surface);
         InterlockedIncrement(&client->ref);
-        surface->client = client;
+        data->client_surface = client;
     }
 
     wayland_win_data_release(data);
@@ -733,7 +733,7 @@ BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffe
 
     if ((wayland_surface = data->wayland_surface))
     {
-        if (wayland_surface_reconfigure(wayland_surface))
+        if (wayland_surface_reconfigure(wayland_surface, data->client_surface))
         {
             wayland_surface_attach_shm(wayland_surface, shm_buffer, damage_region);
             wl_surface_commit(wayland_surface->wl_surface);
@@ -778,13 +778,13 @@ void ensure_window_surface_contents(HWND hwnd)
 
     if ((wayland_surface = data->wayland_surface))
     {
-        wayland_surface_ensure_contents(wayland_surface);
+        wayland_surface_ensure_contents(wayland_surface, data->client_surface);
 
         /* Handle any processed configure request, to ensure the related
          * surface state is applied by the compositor. */
         if (wayland_surface->processing.serial &&
             wayland_surface->processing.processed &&
-            wayland_surface_reconfigure(wayland_surface))
+            wayland_surface_reconfigure(wayland_surface, data->client_surface))
         {
             wl_surface_commit(wayland_surface->wl_surface);
         }
-- 
2.46.0

