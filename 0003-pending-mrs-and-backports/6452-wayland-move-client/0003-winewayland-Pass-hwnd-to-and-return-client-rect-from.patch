From 39c5550f3d617cbeca155938c8297156d39d6f69 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 6 Sep 2024 10:13:24 +0200
Subject: [PATCH 3/5] winewayland: Pass hwnd to and return client rect from
 wayland_surface_get_client.

---
 dlls/winewayland.drv/opengl.c     | 31 +++++--------------------------
 dlls/winewayland.drv/vulkan.c     | 17 ++---------------
 dlls/winewayland.drv/waylanddrv.h |  2 +-
 dlls/winewayland.drv/window.c     | 30 +++++++++++++++++++++++++-----
 4 files changed, 33 insertions(+), 47 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 94ff32c81f1..74c3cb02d8e 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -192,9 +192,8 @@ static inline EGLConfig egl_config_for_format(int format)
 static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int format)
 {
     struct wayland_gl_drawable *gl;
-    struct wayland_surface *wayland_surface;
     int client_width = 0, client_height = 0;
-    struct wayland_win_data *data;
+    RECT client_rect;
 
     TRACE("hwnd=%p format=%d\n", hwnd, format);
 
@@ -208,31 +207,11 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
     /* Get the client surface for the HWND. If don't have a wayland surface
      * (e.g., HWND_MESSAGE windows) just create a dummy surface to act as the
      * target render surface. */
-    if ((data = wayland_win_data_get(hwnd)))
-    {
-        if (!(wayland_surface = data->wayland_surface))
-        {
-            gl->client = wayland_client_surface_create(hwnd);
-            client_width = client_height = 1;
-        }
-        else
-        {
-            gl->client = wayland_surface_get_client(wayland_surface);
-            client_width = wayland_surface->window.client_rect.right -
-                           wayland_surface->window.client_rect.left;
-            client_height = wayland_surface->window.client_rect.bottom -
-                            wayland_surface->window.client_rect.top;
-            if (client_width == 0 || client_height == 0)
-                client_width = client_height = 1;
-        }
-        wayland_win_data_release(data);
-    }
-    else
-    {
-        gl->client = wayland_client_surface_create(hwnd);
+    if (!(gl->client = get_client_surface(hwnd, &client_rect))) goto err;
+    client_width = client_rect.right - client_rect.left;
+    client_height = client_rect.bottom - client_rect.top;
+    if (client_width == 0 || client_height == 0)
         client_width = client_height = 1;
-    }
-    if (!gl->client) goto err;
 
     gl->wl_egl_window = wl_egl_window_create(gl->client->wl_surface,
                                              client_width, client_height);
diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 7a075a925b7..9628fd81fe5 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -73,25 +73,12 @@ static VkResult wayland_vulkan_surface_create(HWND hwnd, VkInstance instance, Vk
 {
     VkResult res;
     VkWaylandSurfaceCreateInfoKHR create_info_host;
-    struct wayland_surface *wayland_surface;
     struct wayland_client_surface *client;
-    struct wayland_win_data *data;
+    RECT client_rect;
 
     TRACE("%p %p %p %p\n", hwnd, instance, surface, private);
 
-    if (!(data = wayland_win_data_get(hwnd)))
-    {
-        ERR("Failed to find wayland surface for hwnd=%p\n", hwnd);
-        return VK_ERROR_OUT_OF_HOST_MEMORY;
-    }
-
-    if ((wayland_surface = data->wayland_surface))
-        client = wayland_surface_get_client(wayland_surface);
-    else
-        client = wayland_client_surface_create(hwnd);
-    wayland_win_data_release(data);
-
-    if (!client)
+    if (!(client = get_client_surface(hwnd, &client_rect)))
     {
         ERR("Failed to create client surface for hwnd=%p\n", hwnd);
         return VK_ERROR_OUT_OF_HOST_MEMORY;
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 39f1e831084..8e1895b9b8d 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -253,7 +253,6 @@ void wayland_surface_coords_to_window(struct wayland_surface *surface,
                                       double surface_x, double surface_y,
                                       int *window_x, int *window_y);
 struct wayland_client_surface *wayland_client_surface_create(HWND hwnd);
-struct wayland_client_surface *wayland_surface_get_client(struct wayland_surface *surface);
 BOOL wayland_client_surface_release(struct wayland_client_surface *client);
 void wayland_client_surface_attach(struct wayland_client_surface *client, struct wayland_surface *surface);
 void wayland_surface_ensure_contents(struct wayland_surface *surface);
@@ -290,6 +289,7 @@ struct wayland_win_data
 struct wayland_win_data *wayland_win_data_get(HWND hwnd);
 void wayland_win_data_release(struct wayland_win_data *data);
 
+struct wayland_client_surface *get_client_surface(HWND hwnd, RECT *client_rect);
 BOOL set_window_surface_contents(HWND hwnd, struct wayland_shm_buffer *shm_buffer, HRGN damage_region);
 struct wayland_shm_buffer *get_window_surface_contents(HWND hwnd);
 void ensure_window_surface_contents(HWND hwnd);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 028de2a2f21..2b6576cb4a4 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -683,23 +683,43 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
 }
 
 /**********************************************************************
- *          wayland_surface_get_client
+ *          get_client_surface
  */
-struct wayland_client_surface *wayland_surface_get_client(struct wayland_surface *surface)
+struct wayland_client_surface *get_client_surface(HWND hwnd, RECT *client_rect)
 {
-    struct wayland_client_surface *client = surface->client;
-    HWND hwnd = surface->hwnd;
+    struct wayland_client_surface *client;
+    struct wayland_surface *surface;
+    struct wayland_win_data *data;
+
+    if (!(data = wayland_win_data_get(hwnd))) surface = NULL;
+    else surface = data->wayland_surface;
+
+    if (surface)
+    {
+        *client_rect = surface->window.client_rect;
+        client = surface->client;
+    }
+    else
+    {
+        SetRectEmpty(client_rect);
+        client = NULL;
+    }
 
     if (!client && !(client = wayland_client_surface_create(hwnd)))
+    {
+        if (data) wayland_win_data_release(data);
         return NULL;
+    }
+    if (!data) return client;
 
-    if (!surface->client)
+    if (surface && !surface->client)
     {
         wayland_client_surface_attach(client, surface);
         InterlockedIncrement(&client->ref);
         surface->client = client;
     }
 
+    wayland_win_data_release(data);
     return client;
 }
 
-- 
2.46.0

