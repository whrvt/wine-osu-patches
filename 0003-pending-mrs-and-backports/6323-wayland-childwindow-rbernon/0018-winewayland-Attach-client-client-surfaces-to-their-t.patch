From f77866da82228a34b855fab93dac8a65e359ed55 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Tue, 20 Aug 2024 15:31:19 +0200
Subject: [PATCH 18/24] winewayland: Attach client client surfaces to their
 toplevel surface.

---
 dlls/winewayland.drv/wayland_surface.c | 23 ++++++----
 dlls/winewayland.drv/waylanddrv.h      |  7 ++--
 dlls/winewayland.drv/window.c          | 58 ++++++++++++++++++++++----
 3 files changed, 69 insertions(+), 19 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 2acd9f09be5..e1edc9297f4 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -480,18 +480,19 @@ static void wayland_surface_reconfigure_size(struct wayland_surface *surface,
  *
  * Reconfigures the subsurface covering the client area.
  */
-void wayland_surface_reconfigure_client(struct wayland_surface *surface, struct wayland_client_surface *client)
+void wayland_surface_reconfigure_client(struct wayland_surface *surface, struct wayland_client_surface *client,
+                                        const RECT *client_rect)
 {
     struct wayland_window_config *window = &surface->window;
     int client_x, client_y, x, y;
     int client_width, client_height, width, height;
 
     /* The offset of the client area origin relatively to the window origin. */
-    client_x = window->client_rect.left - window->rect.left;
-    client_y = window->client_rect.top - window->rect.top;
+    client_x = client_rect->left - window->rect.left;
+    client_y = client_rect->top - window->rect.top;
 
-    client_width = window->client_rect.right - window->client_rect.left;
-    client_height = window->client_rect.bottom - window->client_rect.top;
+    client_width = client_rect->right - client_rect->left;
+    client_height = client_rect->bottom - client_rect->top;
 
     wayland_surface_coords_from_window(surface, client_x, client_y, &x, &y);
     wayland_surface_coords_from_window(surface, client_width, client_height,
@@ -499,7 +500,11 @@ void wayland_surface_reconfigure_client(struct wayland_surface *surface, struct
 
     TRACE("hwnd=%p subsurface=%d,%d+%dx%d\n", surface->hwnd, x, y, width, height);
 
-    wl_subsurface_set_position(client->wl_subsurface, x, y);
+    if (client->wl_subsurface)
+    {
+        wl_subsurface_set_position(client->wl_subsurface, x, y);
+        wl_subsurface_place_above(client->wl_subsurface, surface->wl_surface);
+    }
 
     if (client->wp_viewport)
     {
@@ -576,7 +581,7 @@ BOOL wayland_surface_reconfigure(struct wayland_surface *surface, struct wayland
 
     wayland_surface_reconfigure_geometry(surface, width, height);
     wayland_surface_reconfigure_size(surface, width, height);
-    if (client) wayland_surface_reconfigure_client(surface, client);
+    if (client) wayland_surface_reconfigure_client(surface, client, &surface->window.client_rect);
 
     return TRUE;
 }
@@ -804,7 +809,7 @@ err:
     return NULL;
 }
 
-void wayland_client_surface_attach(struct wayland_client_surface *client, struct wayland_surface *surface)
+void wayland_client_surface_attach(struct wayland_client_surface *client, struct wayland_surface *surface, const RECT *client_rect)
 {
     client->wl_subsurface =
         wl_subcompositor_get_subsurface(process_wayland.wl_subcompositor,
@@ -818,7 +823,7 @@ void wayland_client_surface_attach(struct wayland_client_surface *client, struct
     /* Present contents independently of the parent surface. */
     wl_subsurface_set_desync(client->wl_subsurface);
 
-    wayland_surface_reconfigure_client(surface, client);
+    wayland_surface_reconfigure_client(surface, client, client_rect);
     /* Commit to apply subsurface positioning. */
     wl_surface_commit(surface->wl_surface);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index c717838cefa..a26ca42ea2b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -241,7 +241,8 @@ void wayland_surface_attach_shm(struct wayland_surface *surface,
                                 struct wayland_shm_buffer *shm_buffer,
                                 HRGN surface_damage_region);
 BOOL wayland_surface_reconfigure(struct wayland_surface *surface, struct wayland_client_surface *client_surface);
-void wayland_surface_reconfigure_client(struct wayland_surface *surface, struct wayland_client_surface *client_surface);
+void wayland_surface_reconfigure_client(struct wayland_surface *surface, struct wayland_client_surface *client,
+                                        const RECT *client_rect);
 BOOL wayland_surface_config_is_compatible(struct wayland_surface_config *conf,
                                           int width, int height,
                                           enum wayland_surface_config_state state);
@@ -253,7 +254,7 @@ void wayland_surface_coords_to_window(struct wayland_surface *surface,
                                       int *window_x, int *window_y);
 struct wayland_client_surface *wayland_client_surface_create(HWND hwnd);
 BOOL wayland_client_surface_release(struct wayland_client_surface *client);
-void wayland_client_surface_attach(struct wayland_client_surface *client, struct wayland_surface *surface);
+void wayland_client_surface_attach(struct wayland_client_surface *client, struct wayland_surface *surface, const RECT *client_rect);
 void wayland_client_surface_detach(struct wayland_client_surface *client);
 void wayland_surface_ensure_contents(struct wayland_surface *surface, struct wayland_client_surface *client);
 void wayland_surface_set_title(struct wayland_surface *surface, LPCWSTR title);
@@ -289,7 +290,7 @@ struct wayland_win_data
     struct wayland_surface *wayland_surface;
     /* wayland client surface (if any) for this window */
     struct wayland_client_surface *client_surface;
-    /* window rects, relative to parent client area */
+    /* window rects, relative to desktop window */
     struct window_rects rects;
     BOOL managed;
 };
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 2656dbc6fb7..31528e7b76b 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -125,19 +125,32 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
 }
 
 /***********************************************************************
- *           wayland_win_data_get
+ *           wayland_win_data_get_nolock
  *
- * Lock and return the data structure associated with a window.
+ * Return the data structure associated with a window. This function does
+ * not lock the win_data_mutex, so it must be externally synchronized.
  */
-struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+static struct wayland_win_data *wayland_win_data_get_nolock(HWND hwnd)
 {
     struct rb_entry *rb_entry;
 
-    pthread_mutex_lock(&win_data_mutex);
-
     if ((rb_entry = rb_get(&win_data_rb, hwnd)))
         return RB_ENTRY_VALUE(rb_entry, struct wayland_win_data, entry);
 
+    return NULL;
+}
+
+/***********************************************************************
+ *           wayland_win_data_get
+ *
+ * Lock and return the data structure associated with a window.
+ */
+struct wayland_win_data *wayland_win_data_get(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    pthread_mutex_lock(&win_data_mutex);
+    if ((data = wayland_win_data_get_nolock(hwnd))) return data;
     pthread_mutex_unlock(&win_data_mutex);
 
     return NULL;
@@ -195,12 +208,14 @@ static void reapply_cursor_clipping(void)
 
 static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *data, BOOL visible)
 {
+    struct wayland_client_surface *client;
     struct wayland_surface *surface;
     BOOL xdg_visible;
     WCHAR text[1024];
 
     TRACE("hwnd=%p\n", data->hwnd);
 
+    if ((client = data->client_surface)) wayland_client_surface_detach(client);
     if (!(surface = data->wayland_surface) && !(surface = wayland_surface_create(data->hwnd))) return FALSE;
 
     xdg_visible = surface->xdg_toplevel != NULL;
@@ -225,6 +240,7 @@ static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *dat
     }
 
     wayland_win_data_get_config(data, &surface->window);
+    if (client && visible) wayland_client_surface_attach(client, surface, &surface->window.client_rect);
 
     /* Size/position changes affect the effective pointer constraint, so update
      * it as needed. */
@@ -417,25 +433,48 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, UINT swp_flags, BOOL shaped, struct wi
 void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags, const struct window_rects *new_rects,
                               struct window_surface *surface)
 {
-    struct wayland_win_data *data;
+    struct wayland_win_data *data, *toplevel_data;
+    struct wayland_surface *toplevel_surface;
+    struct window_rects rects = *new_rects;
     BOOL managed, visible;
+    HWND toplevel;
 
     TRACE("hwnd %p new_rects %s after %p flags %08x\n", hwnd, debugstr_window_rects(new_rects), insert_after, swp_flags);
 
     visible = !(swp_flags & SWP_HIDEWINDOW) && ((NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_VISIBLE) || (swp_flags & SWP_SHOWWINDOW));
 
+    if ((toplevel = NtUserGetAncestor(hwnd, GA_ROOT)) == hwnd) toplevel = 0;
+    else
+    {
+        /* keep all rects root-relative to make subsurface positioning easier */
+        UINT count = sizeof(rects) / sizeof(POINT);
+        HWND parent = NtUserGetAncestor(hwnd, GA_PARENT);
+        NtUserMapWindowPoints(parent, 0, (POINT *)&rects, count, 0 /* per-monitor DPI */);
+        new_rects = &rects;
+    }
+
     /* Get the managed state with win_data unlocked, as is_window_managed
      * may need to query win_data information about other HWNDs and thus
      * acquire the lock itself internally. */
     managed = is_window_managed(hwnd, swp_flags, &new_rects->window);
 
     if (!(data = wayland_win_data_get(hwnd))) return;
+    toplevel_data = toplevel ? wayland_win_data_get_nolock(toplevel) : NULL;
+    toplevel_surface = toplevel_data ? toplevel_data->wayland_surface : NULL;
 
     data->rects = *new_rects;
     data->managed = managed;
 
     if (!surface)
     {
+        struct wayland_client_surface *client;
+
+        if ((client = data->client_surface))
+        {
+            wayland_client_surface_detach(client);
+            if (toplevel_surface && visible) wayland_client_surface_attach(client, toplevel_surface, &new_rects->client);
+        }
+
         if (data->wayland_surface)
         {
             wayland_surface_destroy(data->wayland_surface);
@@ -690,6 +729,7 @@ LRESULT WAYLAND_SysCommand(HWND hwnd, WPARAM wparam, LPARAM lparam)
 struct wayland_client_surface *get_client_surface(HWND hwnd, RECT *client_rect)
 {
     BOOL visible = NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_VISIBLE;
+    HWND toplevel = NtUserGetAncestor(hwnd, GA_ROOT);
     struct wayland_client_surface *client;
     struct wayland_surface *wayland_surface;
     struct wayland_win_data *data;
@@ -707,9 +747,13 @@ struct wayland_client_surface *get_client_surface(HWND hwnd, RECT *client_rect)
     if ((wayland_surface = data->wayland_surface))
         *client_rect = wayland_surface->window.client_rect;
     else
+    {
+        struct wayland_win_data *toplevel_data = wayland_win_data_get_nolock(toplevel);
+        if (toplevel_data) wayland_surface = toplevel_data->wayland_surface;
         *client_rect = data->rects.client;
+    }
 
-    if (wayland_surface && visible) wayland_client_surface_attach(client, wayland_surface);
+    if (wayland_surface && visible) wayland_client_surface_attach(client, wayland_surface, client_rect);
 
     if (!data->client_surface) data->client_surface = client;
     else InterlockedIncrement(&client->ref);
-- 
2.46.0

