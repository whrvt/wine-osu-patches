From 935043d39847534a7f67565d262e5ceb23e86559 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 21 Aug 2024 14:06:12 +0200
Subject: [PATCH 21/24] winewayland: Introduce a new wayland_surface role
 enumeration.

---
 dlls/winewayland.drv/wayland_surface.c | 30 +++++++++++++++++-------
 dlls/winewayland.drv/waylanddrv.h      | 20 ++++++++++++++--
 dlls/winewayland.drv/window.c          | 32 ++++++++++++++++++--------
 3 files changed, 62 insertions(+), 20 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 1c260d1c5b4..adbf613d444 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -232,6 +232,12 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface)
 
     TRACE("surface=%p\n", surface);
 
+    assert(!surface->role || surface->role == WAYLAND_SURFACE_ROLE_TOPLEVEL);
+    if (surface->xdg_surface && surface->xdg_toplevel) return;
+
+    wayland_surface_clear_role(surface);
+    surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
+
     surface->xdg_surface =
         xdg_wm_base_get_xdg_surface(process_wayland.xdg_wm_base, surface->wl_surface);
     if (!surface->xdg_surface) goto err;
@@ -269,16 +275,24 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
 {
     TRACE("surface=%p\n", surface);
 
-    if (surface->xdg_toplevel)
+    switch (surface->role)
     {
-        xdg_toplevel_destroy(surface->xdg_toplevel);
-        surface->xdg_toplevel = NULL;
-    }
+    case WAYLAND_SURFACE_ROLE_NONE:
+        break;
 
-    if (surface->xdg_surface)
-    {
-        xdg_surface_destroy(surface->xdg_surface);
-        surface->xdg_surface = NULL;
+    case WAYLAND_SURFACE_ROLE_TOPLEVEL:
+        if (surface->xdg_toplevel)
+        {
+            xdg_toplevel_destroy(surface->xdg_toplevel);
+            surface->xdg_toplevel = NULL;
+        }
+
+        if (surface->xdg_surface)
+        {
+            xdg_surface_destroy(surface->xdg_surface);
+            surface->xdg_surface = NULL;
+        }
+        break;
     }
 
     memset(&surface->pending, 0, sizeof(surface->pending));
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index a26ca42ea2b..85e0cedd619 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -73,6 +73,12 @@ enum wayland_surface_config_state
     WAYLAND_SURFACE_CONFIG_STATE_FULLSCREEN = (1 << 3)
 };
 
+enum wayland_surface_role
+{
+    WAYLAND_SURFACE_ROLE_NONE,
+    WAYLAND_SURFACE_ROLE_TOPLEVEL,
+};
+
 struct wayland_keyboard
 {
     struct wl_keyboard *wl_keyboard;
@@ -192,10 +198,20 @@ struct wayland_client_surface
 struct wayland_surface
 {
     HWND hwnd;
+
     struct wl_surface *wl_surface;
-    struct xdg_surface *xdg_surface;
-    struct xdg_toplevel *xdg_toplevel;
     struct wp_viewport *wp_viewport;
+
+    enum wayland_surface_role role;
+    union
+    {
+        struct
+        {
+            struct xdg_surface *xdg_surface;
+            struct xdg_toplevel *xdg_toplevel;
+        };
+    };
+
     struct wayland_surface_config pending, requested, processing, current;
     BOOL resizing;
     struct wayland_window_config window;
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index c214f0b14a3..181ee59bfb1 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -210,23 +210,35 @@ static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *dat
 {
     struct wayland_client_surface *client;
     struct wayland_surface *surface;
-    BOOL xdg_visible;
+    enum wayland_surface_role role;
 
     TRACE("hwnd=%p\n", data->hwnd);
 
+    if (!visible) role = WAYLAND_SURFACE_ROLE_NONE;
+    else role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
+
     if ((client = data->client_surface)) wayland_client_surface_detach(client);
-    if (!(surface = data->wayland_surface) && !(surface = wayland_surface_create(data->hwnd))) return FALSE;
 
-    xdg_visible = surface->xdg_toplevel != NULL;
+    /* we can temporarily clear the role of a surface but cannot assign a different one after it's set */
+    if ((surface = data->wayland_surface) && role && surface->role && surface->role != role)
+    {
+        wayland_surface_destroy(data->wayland_surface);
+        data->wayland_surface = NULL;
+    }
+
+    if (!(surface = data->wayland_surface) && !(surface = wayland_surface_create(data->hwnd))) return FALSE;
 
-    if (visible != xdg_visible)
+    /* If the window is a visible toplevel make it a wayland
+     * xdg_toplevel. Otherwise keep it role-less to avoid polluting the
+     * compositor with empty xdg_toplevels. */
+    switch (role)
     {
-        /* If we have a pre-existing surface ensure it has no role. */
-        if (data->wayland_surface) wayland_surface_clear_role(surface);
-        /* If the window is a visible toplevel make it a wayland
-         * xdg_toplevel. Otherwise keep it role-less to avoid polluting the
-         * compositor with empty xdg_toplevels. */
-        if (visible) wayland_surface_make_toplevel(surface);
+    case WAYLAND_SURFACE_ROLE_NONE:
+        wayland_surface_clear_role(surface);
+        break;
+    case WAYLAND_SURFACE_ROLE_TOPLEVEL:
+        wayland_surface_make_toplevel(surface);
+        break;
     }
 
     wayland_win_data_get_config(data, &surface->window);
-- 
2.46.0

