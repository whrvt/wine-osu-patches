From c90d7530e9e8daeb166eb5e11a053228e92484c5 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Wed, 21 Aug 2024 14:46:42 +0200
Subject: [PATCH 24/24] winewayland: Use subsurfaces for unmanaged windows.

---
 dlls/winewayland.drv/wayland_surface.c | 107 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   9 +++
 dlls/winewayland.drv/window.c          |  24 +++++-
 3 files changed, 136 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index b8f6cdeb523..5e14724d950 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -264,6 +264,59 @@ err:
     ERR("Failed to assign toplevel role to wayland surface\n");
 }
 
+/**********************************************************************
+ *          wayland_surface_make_subsurface
+ *
+ * Gives the subsurface role to a plain wayland surface.
+ */
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent)
+{
+    struct wl_region *empty_region;
+
+    assert(!surface->role || surface->role == WAYLAND_SURFACE_ROLE_SUBSURFACE);
+    if (surface->wl_subsurface && surface->toplevel_hwnd == parent->hwnd) return;
+
+    wayland_surface_clear_role(surface);
+    surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+
+    TRACE("surface=%p parent=%p\n", surface, parent);
+
+    surface->wl_subsurface =
+        wl_subcompositor_get_subsurface(process_wayland.wl_subcompositor,
+                                        surface->wl_surface,
+                                        parent->wl_surface);
+    if (!surface->wl_subsurface)
+    {
+        ERR("Failed to create client wl_subsurface\n");
+        goto err;
+    }
+
+    surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
+    surface->toplevel_hwnd = parent->hwnd;
+
+    /* Let parent handle all pointer events. */
+    empty_region = wl_compositor_create_region(process_wayland.wl_compositor);
+    if (!empty_region)
+    {
+        ERR("Failed to create wl_region\n");
+        goto err;
+    }
+    wl_surface_set_input_region(surface->wl_surface, empty_region);
+    wl_region_destroy(empty_region);
+
+    /* Present contents independently of the parent surface. */
+    wl_subsurface_set_desync(surface->wl_subsurface);
+
+    wl_display_flush(process_wayland.wl_display);
+
+    return;
+
+err:
+    wayland_surface_clear_role(surface);
+    ERR("Failed to assign subsurface role to wayland surface\n");
+}
+
 /**********************************************************************
  *          wayland_surface_clear_role
  *
@@ -293,12 +346,23 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
             surface->xdg_surface = NULL;
         }
         break;
+
+    case WAYLAND_SURFACE_ROLE_SUBSURFACE:
+        if (surface->wl_subsurface)
+        {
+            wl_subsurface_destroy(surface->wl_subsurface);
+            surface->wl_subsurface = NULL;
+        }
+
+        surface->toplevel_hwnd = 0;
+        break;
     }
 
     memset(&surface->pending, 0, sizeof(surface->pending));
     memset(&surface->requested, 0, sizeof(surface->requested));
     memset(&surface->processing, 0, sizeof(surface->processing));
     memset(&surface->current, 0, sizeof(surface->current));
+    surface->toplevel_hwnd = 0;
 
     /* Ensure no buffer is attached, otherwise future role assignments may fail. */
     wl_surface_attach(surface->wl_surface, NULL, 0, 0);
@@ -580,6 +644,46 @@ static BOOL wayland_surface_reconfigure_xdg(struct wayland_surface *surface,
     return TRUE;
 }
 
+/**********************************************************************
+ *          wayland_surface_reconfigure_subsurface
+ *
+ * Reconfigures the subsurface as needed to match the latest requested
+ * state.
+ */
+static void wayland_surface_reconfigure_subsurface(struct wayland_surface *surface)
+{
+    struct wayland_win_data *toplevel_data;
+    struct wayland_surface *toplevel_surface;
+    int local_x, local_y, x, y;
+
+    if (surface->processing.serial && surface->processing.processed &&
+        (toplevel_data = wayland_win_data_get_nolock(surface->toplevel_hwnd)) &&
+        (toplevel_surface = toplevel_data->wayland_surface))
+    {
+        local_x = surface->window.rect.left - toplevel_surface->window.rect.left;
+        local_y = surface->window.rect.top - toplevel_surface->window.rect.top;
+
+        wayland_surface_coords_from_window(surface, local_x, local_y, &x, &y);
+
+        TRACE("hwnd=%p pos=%d,%d\n", surface->hwnd, x, y);
+
+        wl_subsurface_set_position(surface->wl_subsurface, x, y);
+        if (toplevel_data->client_surface)
+            wl_subsurface_place_above(surface->wl_subsurface, toplevel_data->client_surface->wl_surface);
+        else
+            wl_subsurface_place_above(surface->wl_subsurface, toplevel_surface->wl_surface);
+        wl_surface_commit(toplevel_surface->wl_surface);
+
+        memset(&surface->processing, 0, sizeof(surface->processing));
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_reconfigure
+ *
+ * Reconfigures the wayland surface as needed to match the latest requested
+ * state.
+ */
 BOOL wayland_surface_reconfigure(struct wayland_surface *surface, struct wayland_client_surface *client)
 {
     struct wayland_window_config *window = &surface->window;
@@ -604,6 +708,9 @@ BOOL wayland_surface_reconfigure(struct wayland_surface *surface, struct wayland
     case WAYLAND_SURFACE_ROLE_TOPLEVEL:
         if (!wayland_surface_reconfigure_xdg(surface, width, height)) return FALSE;
         break;
+    case WAYLAND_SURFACE_ROLE_SUBSURFACE:
+        wayland_surface_reconfigure_subsurface(surface);
+        break;
     }
 
     wayland_surface_reconfigure_size(surface, width, height);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 85e0cedd619..385415c7fcb 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -77,6 +77,7 @@ enum wayland_surface_role
 {
     WAYLAND_SURFACE_ROLE_NONE,
     WAYLAND_SURFACE_ROLE_TOPLEVEL,
+    WAYLAND_SURFACE_ROLE_SUBSURFACE,
 };
 
 struct wayland_keyboard
@@ -210,6 +211,11 @@ struct wayland_surface
             struct xdg_surface *xdg_surface;
             struct xdg_toplevel *xdg_toplevel;
         };
+        struct
+        {
+            struct wl_subsurface *wl_subsurface;
+            HWND toplevel_hwnd;
+        };
     };
 
     struct wayland_surface_config pending, requested, processing, current;
@@ -252,6 +258,8 @@ void wayland_output_use_xdg_extension(struct wayland_output *output);
 struct wayland_surface *wayland_surface_create(HWND hwnd);
 void wayland_surface_destroy(struct wayland_surface *surface);
 void wayland_surface_make_toplevel(struct wayland_surface *surface);
+void wayland_surface_make_subsurface(struct wayland_surface *surface,
+                                     struct wayland_surface *parent);
 void wayland_surface_clear_role(struct wayland_surface *surface);
 void wayland_surface_attach_shm(struct wayland_surface *surface,
                                 struct wayland_shm_buffer *shm_buffer,
@@ -312,6 +320,7 @@ struct wayland_win_data
 };
 
 struct wayland_win_data *wayland_win_data_get(HWND hwnd);
+struct wayland_win_data *wayland_win_data_get_nolock(HWND hwnd);
 void wayland_win_data_release(struct wayland_win_data *data);
 
 struct wayland_client_surface *get_client_surface(HWND hwnd, RECT *client_rect);
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 7869907e58c..5e80303b780 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -130,7 +130,7 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
  * Return the data structure associated with a window. This function does
  * not lock the win_data_mutex, so it must be externally synchronized.
  */
-static struct wayland_win_data *wayland_win_data_get_nolock(HWND hwnd)
+struct wayland_win_data *wayland_win_data_get_nolock(HWND hwnd)
 {
     struct rb_entry *rb_entry;
 
@@ -206,7 +206,7 @@ static void reapply_cursor_clipping(void)
     NtUserSetThreadDpiAwarenessContext(context);
 }
 
-static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *data, BOOL visible)
+static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *data, BOOL visible, struct wayland_surface *toplevel_surface)
 {
     struct wayland_client_surface *client;
     struct wayland_surface *surface;
@@ -215,6 +215,7 @@ static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *dat
     TRACE("hwnd=%p\n", data->hwnd);
 
     if (!visible) role = WAYLAND_SURFACE_ROLE_NONE;
+    else if (toplevel_surface) role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
     else role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
 
     if ((client = data->client_surface)) wayland_client_surface_detach(client);
@@ -239,6 +240,9 @@ static BOOL wayland_win_data_create_wayland_surface(struct wayland_win_data *dat
     case WAYLAND_SURFACE_ROLE_TOPLEVEL:
         wayland_surface_make_toplevel(surface);
         break;
+    case WAYLAND_SURFACE_ROLE_SUBSURFACE:
+        wayland_surface_make_subsurface(surface, toplevel_surface);
+        break;
     }
 
     wayland_win_data_get_config(data, &surface->window);
@@ -308,6 +312,13 @@ static void wayland_win_data_update_wayland_state(struct wayland_win_data *data)
     case WAYLAND_SURFACE_ROLE_TOPLEVEL:
         wayland_surface_update_state_toplevel(surface);
         break;
+    case WAYLAND_SURFACE_ROLE_SUBSURFACE:
+        TRACE("hwnd=%p subsurface parent=%p\n", surface->hwnd, surface->toplevel_hwnd);
+        /* Although subsurfaces don't have a dedicated surface config mechanism,
+         * we use the config fields to mark them as updated. */
+        surface->processing.serial = 1;
+        surface->processing.processed = TRUE;
+        break;
     }
 
     wl_display_flush(process_wayland.wl_display);
@@ -466,7 +477,12 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags, cons
     /* Get the managed state with win_data unlocked, as is_window_managed
      * may need to query win_data information about other HWNDs and thus
      * acquire the lock itself internally. */
-    managed = is_window_managed(hwnd, swp_flags, &new_rects->window);
+    if (!(managed = is_window_managed(hwnd, swp_flags, &new_rects->window)) && surface)
+    {
+        toplevel = NtUserGetWindowRelative(hwnd, GW_OWNER);
+        if (toplevel) toplevel = NtUserGetAncestor(toplevel, GA_ROOT);
+        if (!toplevel) toplevel = NtUserWindowFromPoint(new_rects->window.left - 1, new_rects->window.top - 1);
+    }
 
     if (!(data = wayland_win_data_get(hwnd))) return;
     toplevel_data = toplevel ? wayland_win_data_get_nolock(toplevel) : NULL;
@@ -491,7 +507,7 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags, cons
             data->wayland_surface = NULL;
         }
     }
-    else if (wayland_win_data_create_wayland_surface(data, visible))
+    else if (wayland_win_data_create_wayland_surface(data, visible, toplevel_surface))
     {
         wayland_window_surface_set_visible_rect(surface, &data->rects.visible);
         wayland_win_data_update_wayland_state(data);
-- 
2.46.0

