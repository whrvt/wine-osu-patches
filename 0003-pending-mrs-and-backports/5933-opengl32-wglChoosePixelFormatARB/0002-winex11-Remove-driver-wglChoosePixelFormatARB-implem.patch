From b71d250f5142f645b4da4f32be5f24fc7e0004fa Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 25 Jun 2024 13:59:38 +0300
Subject: [PATCH 2/4] winex11: Remove driver wglChoosePixelFormatARB
 implementation.

The driver uses the default implementation provided by opengl32.dll.
---
 dlls/winex11.drv/opengl.c | 382 +-------------------------------------
 1 file changed, 1 insertion(+), 381 deletions(-)

diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 3979d31a334..5d914b74f0a 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -743,224 +743,6 @@ static const char *debugstr_fbconfig( GLXFBConfig fbconfig )
     return wine_dbg_sprintf( "fbconfig %#x visual id %#x drawable type %#x", id, visual, drawable );
 }
 
-static int ConvertAttribWGLtoGLX(const int* iWGLAttr, int* oGLXAttr, struct wgl_pbuffer* pbuf) {
-  int nAttribs = 0;
-  unsigned cur = 0; 
-  int attr, pop;
-  int drawattrib = 0;
-  int nvfloatattrib = GLX_DONT_CARE;
-  int pixelattrib = GLX_DONT_CARE;
-
-  /* The list of WGL attributes is allowed to be NULL. We don't return here for NULL
-   * because we need to do fixups for GLX_DRAWABLE_TYPE/GLX_RENDER_TYPE/GLX_FLOAT_COMPONENTS_NV. */
-  while (iWGLAttr && 0 != iWGLAttr[cur]) {
-    attr = iWGLAttr[cur];
-    TRACE("pAttr[%d] = %x\n", cur, attr);
-    pop = iWGLAttr[++cur];
-
-    switch (attr) {
-    case WGL_AUX_BUFFERS_ARB:
-      PUSH2(oGLXAttr, GLX_AUX_BUFFERS, pop);
-      TRACE("pAttr[%d] = GLX_AUX_BUFFERS: %d\n", cur, pop);
-      break;
-    case WGL_COLOR_BITS_ARB:
-      PUSH2(oGLXAttr, GLX_BUFFER_SIZE, pop);
-      TRACE("pAttr[%d] = GLX_BUFFER_SIZE: %d\n", cur, pop);
-      break;
-    case WGL_BLUE_BITS_ARB:
-      PUSH2(oGLXAttr, GLX_BLUE_SIZE, pop);
-      TRACE("pAttr[%d] = GLX_BLUE_SIZE: %d\n", cur, pop);
-      break;
-    case WGL_RED_BITS_ARB:
-      PUSH2(oGLXAttr, GLX_RED_SIZE, pop);
-      TRACE("pAttr[%d] = GLX_RED_SIZE: %d\n", cur, pop);
-      break;
-    case WGL_GREEN_BITS_ARB:
-      PUSH2(oGLXAttr, GLX_GREEN_SIZE, pop);
-      TRACE("pAttr[%d] = GLX_GREEN_SIZE: %d\n", cur, pop);
-      break;
-    case WGL_ALPHA_BITS_ARB:
-      PUSH2(oGLXAttr, GLX_ALPHA_SIZE, pop);
-      TRACE("pAttr[%d] = GLX_ALPHA_SIZE: %d\n", cur, pop);
-      break;
-    case WGL_DEPTH_BITS_ARB:
-      PUSH2(oGLXAttr, GLX_DEPTH_SIZE, pop);
-      TRACE("pAttr[%d] = GLX_DEPTH_SIZE: %d\n", cur, pop);
-      break;
-    case WGL_STENCIL_BITS_ARB:
-      PUSH2(oGLXAttr, GLX_STENCIL_SIZE, pop);
-      TRACE("pAttr[%d] = GLX_STENCIL_SIZE: %d\n", cur, pop);
-      break;
-    case WGL_DOUBLE_BUFFER_ARB:
-      PUSH2(oGLXAttr, GLX_DOUBLEBUFFER, pop);
-      TRACE("pAttr[%d] = GLX_DOUBLEBUFFER: %d\n", cur, pop);
-      break;
-    case WGL_STEREO_ARB:
-      PUSH2(oGLXAttr, GLX_STEREO, pop);
-      TRACE("pAttr[%d] = GLX_STEREO: %d\n", cur, pop);
-      break;
-
-    case WGL_PIXEL_TYPE_ARB:
-      TRACE("pAttr[%d] = WGL_PIXEL_TYPE_ARB: %d\n", cur, pop);
-      switch (pop) {
-      case WGL_TYPE_COLORINDEX_ARB: pixelattrib = GLX_COLOR_INDEX_BIT; break ;
-      case WGL_TYPE_RGBA_ARB: pixelattrib = GLX_RGBA_BIT; break ;
-      /* This is the same as WGL_TYPE_RGBA_FLOAT_ATI but the GLX constants differ, only the ARB GLX one is widely supported so use that */
-      case WGL_TYPE_RGBA_FLOAT_ATI: pixelattrib = GLX_RGBA_FLOAT_BIT; break ;
-      case WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT: pixelattrib = GLX_RGBA_UNSIGNED_FLOAT_BIT_EXT; break ;
-      default:
-        ERR("unexpected PixelType(%x)\n", pop);	
-      }
-      break;
-
-    case WGL_SUPPORT_GDI_ARB:
-      /* This flag is set in a pixel format */
-      TRACE("pAttr[%d] = WGL_SUPPORT_GDI_ARB: %d\n", cur, pop);
-      break;
-
-    case WGL_DRAW_TO_BITMAP_ARB:
-      /* This flag is set in a pixel format */
-      TRACE("pAttr[%d] = WGL_DRAW_TO_BITMAP_ARB: %d\n", cur, pop);
-      break;
-
-    case WGL_DRAW_TO_WINDOW_ARB:
-      TRACE("pAttr[%d] = WGL_DRAW_TO_WINDOW_ARB: %d\n", cur, pop);
-      /* GLX_DRAWABLE_TYPE flags need to be OR'd together. See below. */
-      if (pop) {
-        drawattrib |= GLX_WINDOW_BIT;
-      }
-      break;
-
-    case WGL_DRAW_TO_PBUFFER_ARB:
-      TRACE("pAttr[%d] = WGL_DRAW_TO_PBUFFER_ARB: %d\n", cur, pop);
-      /* GLX_DRAWABLE_TYPE flags need to be OR'd together. See below. */
-      if (pop) {
-        drawattrib |= GLX_PBUFFER_BIT;
-      }
-      break;
-
-    case WGL_ACCELERATION_ARB:
-      /* This flag is set in a pixel format */
-      TRACE("pAttr[%d] = WGL_ACCELERATION_ARB: %d\n", cur, pop);
-      break;
-
-    case WGL_SUPPORT_OPENGL_ARB:
-      /** nothing to do, if we are here, supposing support Accelerated OpenGL */
-      TRACE("pAttr[%d] = WGL_SUPPORT_OPENGL_ARB: %d\n", cur, pop);
-      break;
-
-    case WGL_SWAP_METHOD_ARB:
-      TRACE("pAttr[%d] = WGL_SWAP_METHOD_ARB: %#x\n", cur, pop);
-      if (has_swap_method)
-      {
-          switch (pop)
-          {
-          case WGL_SWAP_EXCHANGE_ARB:
-              pop = GLX_SWAP_EXCHANGE_OML;
-              break;
-          case WGL_SWAP_COPY_ARB:
-              pop = GLX_SWAP_COPY_OML;
-              break;
-          case WGL_SWAP_UNDEFINED_ARB:
-              pop = GLX_SWAP_UNDEFINED_OML;
-              break;
-          default:
-              ERR("Unexpected swap method %#x.\n", pop);
-              pop = GLX_DONT_CARE;
-          }
-          PUSH2(oGLXAttr, GLX_SWAP_METHOD_OML, pop);
-      }
-      else
-      {
-          WARN("GLX_OML_swap_method not supported, ignoring attribute.\n");
-      }
-      break;
-
-    case WGL_PBUFFER_LARGEST_ARB:
-      PUSH2(oGLXAttr, GLX_LARGEST_PBUFFER, pop);
-      TRACE("pAttr[%d] = GLX_LARGEST_PBUFFER: %x\n", cur, pop);
-      break;
-
-    case WGL_SAMPLE_BUFFERS_ARB:
-      PUSH2(oGLXAttr, GLX_SAMPLE_BUFFERS_ARB, pop);
-      TRACE("pAttr[%d] = GLX_SAMPLE_BUFFERS_ARB: %x\n", cur, pop);
-      break;
-
-    case WGL_SAMPLES_ARB:
-      PUSH2(oGLXAttr, GLX_SAMPLES_ARB, pop);
-      TRACE("pAttr[%d] = GLX_SAMPLES_ARB: %x\n", cur, pop);
-      break;
-
-    case WGL_TEXTURE_FORMAT_ARB:
-    case WGL_TEXTURE_TARGET_ARB:
-    case WGL_MIPMAP_TEXTURE_ARB:
-      TRACE("WGL_render_texture Attributes: %x as %x\n", iWGLAttr[cur - 1], iWGLAttr[cur]);
-      if (NULL == pbuf) {
-        ERR("trying to use GLX_Pbuffer Attributes without Pbuffer (was %x)\n", iWGLAttr[cur]);
-      }
-      if (!use_render_texture_emulation) {
-        if (WGL_NO_TEXTURE_ARB != pop) {
-          ERR("trying to use WGL_render_texture Attributes without support (was %x)\n", iWGLAttr[cur]);
-          return -1; /** error: don't support it */
-        } else {
-          drawattrib |= GLX_PBUFFER_BIT;
-        }
-      }
-      break ;
-    case WGL_FLOAT_COMPONENTS_NV:
-      nvfloatattrib = pop;
-      TRACE("pAttr[%d] = WGL_FLOAT_COMPONENTS_NV: %x\n", cur, nvfloatattrib);
-      break ;
-    case WGL_BIND_TO_TEXTURE_DEPTH_NV:
-    case WGL_BIND_TO_TEXTURE_RGB_ARB:
-    case WGL_BIND_TO_TEXTURE_RGBA_ARB:
-    case WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_R_NV:
-    case WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RG_NV:
-    case WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGB_NV:
-    case WGL_BIND_TO_TEXTURE_RECTANGLE_FLOAT_RGBA_NV:
-      /** cannot be converted, see direct handling on 
-       *   - wglGetPixelFormatAttribivARB
-       *  TODO: wglChoosePixelFormat
-       */
-      break ;
-    case WGL_FRAMEBUFFER_SRGB_CAPABLE_EXT:
-      PUSH2(oGLXAttr, GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT, pop);
-      TRACE("pAttr[%d] = GLX_FRAMEBUFFER_SRGB_CAPABLE_EXT: %x\n", cur, pop);
-      break ;
-
-    case WGL_TYPE_RGBA_UNSIGNED_FLOAT_EXT:
-      PUSH2(oGLXAttr, GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT, pop);
-      TRACE("pAttr[%d] = GLX_RGBA_UNSIGNED_FLOAT_TYPE_EXT: %x\n", cur, pop);
-      break ;
-    default:
-      FIXME("unsupported %x WGL Attribute\n", attr);
-      break;
-    }
-    ++cur;
-  }
-
-  /* By default glXChooseFBConfig defaults to GLX_WINDOW_BIT. wglChoosePixelFormatARB searches through
-   * all formats. Unless drawattrib is set to a non-zero value override it with GLX_DONT_CARE, so that
-   * pixmap and pbuffer formats appear as well. */
-  if (!drawattrib) drawattrib = GLX_DONT_CARE;
-  PUSH2(oGLXAttr, GLX_DRAWABLE_TYPE, drawattrib);
-  TRACE("pAttr[?] = GLX_DRAWABLE_TYPE: %#x\n", drawattrib);
-
-  /* By default glXChooseFBConfig uses GLX_RGBA_BIT as the default value. Since wglChoosePixelFormatARB
-   * searches in all formats we have to do the same. For this reason we set GLX_RENDER_TYPE to
-   * GLX_DONT_CARE unless it is overridden. */
-  PUSH2(oGLXAttr, GLX_RENDER_TYPE, pixelattrib);
-  TRACE("pAttr[?] = GLX_RENDER_TYPE: %#x\n", pixelattrib);
-
-  /* Set GLX_FLOAT_COMPONENTS_NV all the time */
-  if (has_extension(glxExtensions, "GLX_NV_float_buffer")) {
-    PUSH2(oGLXAttr, GLX_FLOAT_COMPONENTS_NV, nvfloatattrib);
-    TRACE("pAttr[?] = GLX_FLOAT_COMPONENTS_NV: %#x\n", nvfloatattrib);
-  }
-
-  return nAttribs;
-}
-
 static int get_render_type_from_fbconfig(Display *display, GLXFBConfig fbconfig)
 {
     int render_type, render_type_bit;
@@ -2592,168 +2374,6 @@ static BOOL X11DRV_wglSetPbufferAttribARB( struct wgl_pbuffer *object, const int
     return ret;
 }
 
-struct choose_pixel_format_arb_format
-{
-    int format;
-    int original_index;
-    struct wgl_pixel_format pf;
-    int depth, stencil;
-};
-
-static int compare_formats(const void *a, const void *b)
-{
-    /* Order formats so that onscreen formats go first. Then, if no depth bits requested,
-     * prioritize formats with smaller depth within the original sort order with respect to
-     * other attributes. */
-    const struct choose_pixel_format_arb_format *fmt_a = a, *fmt_b = b;
-    BOOL offscreen_a, offscreen_b;
-
-    offscreen_a = fmt_a->format > nb_onscreen_formats;
-    offscreen_b = fmt_b->format > nb_onscreen_formats;
-
-    if (offscreen_a != offscreen_b)
-        return offscreen_a - offscreen_b;
-    if (memcmp(&fmt_a->pf.pfd, &fmt_b->pf.pfd, sizeof(fmt_a->pf.pfd)))
-        return fmt_a->original_index - fmt_b->original_index;
-    if (fmt_a->depth != fmt_b->depth)
-        return fmt_a->depth - fmt_b->depth;
-    if (fmt_a->stencil != fmt_b->stencil)
-        return fmt_a->stencil - fmt_b->stencil;
-
-    return fmt_a->original_index - fmt_b->original_index;
-}
-
-/**
- * X11DRV_wglChoosePixelFormatARB
- *
- * WGL_ARB_pixel_format: wglChoosePixelFormatARB
- */
-static BOOL X11DRV_wglChoosePixelFormatARB( HDC hdc, const int *piAttribIList, const FLOAT *pfAttribFList,
-                                            UINT nMaxFormats, int *piFormats, UINT *nNumFormats )
-{
-    struct choose_pixel_format_arb_format *formats;
-    int it, i, format_count;
-    BYTE depth_bits = 0;
-    GLXFBConfig* cfgs;
-    DWORD dwFlags = 0;
-    int attribs[256];
-    int nAttribs = 0;
-    int nCfgs = 0;
-    int fmt_id;
-
-    TRACE("(%p, %p, %p, %d, %p, %p): hackish\n", hdc, piAttribIList, pfAttribFList, nMaxFormats, piFormats, nNumFormats);
-    if (NULL != pfAttribFList) {
-        FIXME("unused pfAttribFList\n");
-    }
-
-    nAttribs = ConvertAttribWGLtoGLX(piAttribIList, attribs, NULL);
-    if (-1 == nAttribs) {
-        WARN("Cannot convert WGL to GLX attributes\n");
-        return GL_FALSE;
-    }
-    PUSH1(attribs, None);
-
-    /* There is no 1:1 mapping between GLX and WGL formats because we duplicate some GLX formats for bitmap rendering (see get_formats).
-     * Flags like PFD_SUPPORT_GDI, PFD_DRAW_TO_BITMAP and others are a property of the pixel format. We don't query these attributes
-     * using glXChooseFBConfig but we filter the result of glXChooseFBConfig later on.
-     */
-    for(i=0; piAttribIList[i] != 0; i+=2)
-    {
-        switch(piAttribIList[i])
-        {
-            case WGL_DRAW_TO_BITMAP_ARB:
-                if(piAttribIList[i+1])
-                    dwFlags |= PFD_DRAW_TO_BITMAP;
-                break;
-            case WGL_ACCELERATION_ARB:
-                switch(piAttribIList[i+1])
-                {
-                    case WGL_NO_ACCELERATION_ARB:
-                        dwFlags |= PFD_GENERIC_FORMAT;
-                        break;
-                    case WGL_GENERIC_ACCELERATION_ARB:
-                        dwFlags |= PFD_GENERIC_ACCELERATED;
-                        break;
-                    case WGL_FULL_ACCELERATION_ARB:
-                        /* Nothing to do */
-                        break;
-                }
-                break;
-            case WGL_SUPPORT_GDI_ARB:
-                if(piAttribIList[i+1])
-                    dwFlags |= PFD_SUPPORT_GDI;
-                break;
-            case WGL_DEPTH_BITS_ARB:
-                depth_bits = piAttribIList[i+1];
-                break;
-
-        }
-    }
-
-    /* Search for FB configurations matching the requirements in attribs */
-    cfgs = pglXChooseFBConfig(gdi_display, DefaultScreen(gdi_display), attribs, &nCfgs);
-    if (NULL == cfgs) {
-        WARN("Compatible Pixel Format not found\n");
-        return GL_FALSE;
-    }
-
-    if (!(formats = malloc( nCfgs * sizeof(*formats) )))
-    {
-        ERR("No memory.\n");
-        XFree(cfgs);
-        return GL_FALSE;
-    }
-
-    format_count = 0;
-    for (it = 0; it < nCfgs; ++it)
-    {
-        struct choose_pixel_format_arb_format *format;
-
-        if (pglXGetFBConfigAttrib(gdi_display, cfgs[it], GLX_FBCONFIG_ID, &fmt_id))
-        {
-            ERR("Failed to retrieve FBCONFIG_ID from GLXFBConfig, expect problems.\n");
-            continue;
-        }
-
-        for (i = 0; i < nb_pixel_formats; ++i)
-            if (pixel_formats[i].fmt_id == fmt_id)
-                break;
-
-        if (i == nb_pixel_formats)
-            continue;
-        if ((pixel_formats[i].dwFlags & dwFlags) != dwFlags)
-            continue;
-
-        format = &formats[format_count];
-        format->format = i + 1;
-        format->original_index = it;
-
-        memset(&format->pf, 0, sizeof(format->pf));
-        if (!describe_pixel_format(format->format, &format->pf))
-            ERR("describe_pixel_format failed, format %d.\n", format->format);
-
-        format->depth = format->pf.pfd.cDepthBits;
-        format->stencil = format->pf.pfd.cStencilBits;
-        if (!depth_bits && !(format->pf.pfd.dwFlags & PFD_GENERIC_FORMAT))
-        {
-            format->pf.pfd.cDepthBits = 0;
-            format->pf.pfd.cStencilBits = 0;
-        }
-
-        ++format_count;
-    }
-
-    qsort(formats, format_count, sizeof(*formats), compare_formats);
-
-    *nNumFormats = min(nMaxFormats, format_count);
-    for (i = 0; i < *nNumFormats; ++i)
-        piFormats[i] = formats[i].format;
-
-    free( formats );
-    XFree(cfgs);
-    return GL_TRUE;
-}
-
 /**
  * X11DRV_wglBindTexImageARB
  *
@@ -3012,7 +2632,7 @@ static void X11DRV_WineGL_LoadExtensions(void)
     }
 
     register_extension( "WGL_ARB_pixel_format" );
-    opengl_funcs.ext.p_wglChoosePixelFormatARB      = X11DRV_wglChoosePixelFormatARB;
+    opengl_funcs.ext.p_wglChoosePixelFormatARB      = (void *)1; /* never called */
     opengl_funcs.ext.p_wglGetPixelFormatAttribfvARB = (void *)1; /* never called */
     opengl_funcs.ext.p_wglGetPixelFormatAttribivARB = (void *)1; /* never called */
 
-- 
2.45.2

