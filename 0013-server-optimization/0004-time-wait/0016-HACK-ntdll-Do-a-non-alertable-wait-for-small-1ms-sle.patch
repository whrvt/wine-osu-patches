From 26e2cd0cc7668c16eb7c6404ef34f6b5741ee629 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Wed, 12 Feb 2025 15:49:34 -0800
Subject: [PATCH] HACK: ntdll: Do a non-alertable wait for small (<=1ms) sleeps
 in osu!.

Also allow forcing it on (with WINE_FORCE_BUSYWAIT=1) for the placebo-chasers
out there who might use this build for other games, to see how it affects them.

Only with ntsync/esync/server sync, as fsync is fast enough already.
---
 dlls/ntdll/unix/loader.c       |  7 +++++++
 dlls/ntdll/unix/sync.c         | 20 ++++++++++++++++++++
 dlls/ntdll/unix/unix_private.h |  1 +
 3 files changed, 28 insertions(+)

diff --git a/dlls/ntdll/unix/loader.c b/dlls/ntdll/unix/loader.c
index 2334b46ac81..02d2551ce5d 100644
--- a/dlls/ntdll/unix/loader.c
+++ b/dlls/ntdll/unix/loader.c
@@ -1857,6 +1857,7 @@ static ULONG_PTR get_image_address(void)
     return 0;
 }
 
+BOOL smallsleep_noalert;
 BOOL ac_odyssey;
 BOOL fsync_simulate_sched_quantum;
 BOOL alert_simulate_sched_quantum;
@@ -1910,6 +1911,12 @@ static void hacks_init(void)
     if (env_str)  no_priv_elevation = atoi(env_str);
     else if (sgi) no_priv_elevation = !strcmp(sgi, "1584660");
 
+    env_str = getenv("WINE_FORCE_BUSYWAIT");
+    if (env_str)
+        smallsleep_noalert = !!atoi(env_str);
+    else if (main_argc > 1 && strstr(main_argv[1], "osu!.exe"))
+        smallsleep_noalert = TRUE;
+
 }
 
 /***********************************************************************
diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index b4109b7545b..84699e7184d 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -2751,6 +2751,18 @@ NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeou
 {
     unsigned int status = STATUS_SUCCESS;
 
+    static BOOL cached_result = FALSE;
+    static DWORD last_check_time = 0;
+    BOOL do_check = FALSE;
+
+    if (!do_fsync() && smallsleep_noalert && alertable && timeout && timeout->QuadPart <= 0 && timeout->QuadPart >= -10000)
+    {
+        do_check = (NtGetTickCount() - last_check_time >= 100000);
+
+        if (!do_check && cached_result)
+            alertable = FALSE;
+    }
+
     /* if alertable, we need to query the server */
     if (alertable)
     {
@@ -2775,6 +2787,14 @@ NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeou
 alert_waited:
         if (status == STATUS_TIMEOUT)
             status = STATUS_SUCCESS;
+
+        if (do_check)
+        {
+            if (status != STATUS_USER_APC)
+                cached_result = TRUE;
+            last_check_time = NtGetTickCount();
+        }
+
         return status;
     }
 
diff --git a/dlls/ntdll/unix/unix_private.h b/dlls/ntdll/unix/unix_private.h
index e20de9214d6..73d9689541a 100644
--- a/dlls/ntdll/unix/unix_private.h
+++ b/dlls/ntdll/unix/unix_private.h
@@ -196,6 +196,7 @@ #ifdef __i386__
 extern struct ldt_copy __wine_ldt_copy;
 #endif
 
+extern BOOL smallsleep_noalert;
 extern BOOL ac_odyssey;
 extern BOOL fsync_simulate_sched_quantum;
 extern BOOL alert_simulate_sched_quantum;
-- 
2.48.1

