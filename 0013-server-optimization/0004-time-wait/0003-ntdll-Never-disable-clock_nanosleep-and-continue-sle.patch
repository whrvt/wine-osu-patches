From 2d1eb19681f28834f797e869c8b4df71e9a5bd84 Mon Sep 17 00:00:00 2001
From: William Horvath <william@horvath.blog>
Date: Tue, 10 Sep 2024 02:52:21 -0700
Subject: [PATCH] ntdll: Never disable clock_nanosleep and continue sleep with
 remaining time on EINTR.

---
 dlls/ntdll/unix/sync.c | 45 +++++++++++++++++++++++++++++++-----------
 1 file changed, 34 insertions(+), 11 deletions(-)

diff --git a/dlls/ntdll/unix/sync.c b/dlls/ntdll/unix/sync.c
index b93aacb9d6a..aa1cbe38b5d 100644
--- a/dlls/ntdll/unix/sync.c
+++ b/dlls/ntdll/unix/sync.c
@@ -1830,6 +1830,23 @@ NTSTATUS WINAPI NtYieldExecution(void)
 #endif
 }
 
+#if defined(HAVE_CLOCK_GETTIME) && defined(HAVE_CLOCK_NANOSLEEP)
+/* Based on glibc's TEMP_FAILURE_RETRY macro: https://www.gnu.org/software/libc/manual/html_node/Interrupted-Primitives.html 
+ * Nested for clock_nanosleep to retry with the time remaining on EINTR
+ */
+#define TEMP_FAILURE_RETRY_CLOCK_NANOSLEEP(clock_id, flags, request, remaining) \
+    ({ \
+        int __result; \
+        struct timespec __temp_request = *(request); \
+        do { \
+            __result = clock_nanosleep(clock_id, flags, &__temp_request, remaining); \
+            if (__result == -1 && errno == EINTR) { \
+                __temp_request = *(remaining); \
+            } \
+        } while (__result == -1 && errno == EINTR); \
+        __result; \
+    })
+#endif
 
 /******************************************************************
  *		NtDelayExecution (NTDLL.@)
@@ -1867,31 +1884,36 @@ NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeou
         timeout_t when = ticks, diff;
 
 #if defined(HAVE_CLOCK_GETTIME) && defined(HAVE_CLOCK_NANOSLEEP)
-        static BOOL disable_clock_nanosleep = FALSE;
-        if (!disable_clock_nanosleep && ticks != 0)
+        if (ticks != 0)
         {
-            struct timespec when;
+            struct timespec nano_timeout;
             int err;
 
             if (ticks < 0)
             {
-                clock_gettime( CLOCK_REALTIME, &when );
-                when.tv_sec += (time_t)(-ticks / TICKSPERSEC);
-                when.tv_nsec += (long)((-ticks % TICKSPERSEC) * 100);
+                clock_gettime( CLOCK_REALTIME, &nano_timeout );
+                nano_timeout.tv_sec += (time_t)(-ticks / TICKSPERSEC);
+                nano_timeout.tv_nsec += (long)((-ticks % TICKSPERSEC) * 100);
             }
             else
             {
-                when.tv_sec = (time_t)((ticks / TICKSPERSEC) - SECS_1601_TO_1970);
-                when.tv_nsec = (long)((ticks % TICKSPERSEC) * 100);
+                nano_timeout.tv_sec = (time_t)((ticks / TICKSPERSEC) - SECS_1601_TO_1970);
+                nano_timeout.tv_nsec = (long)((ticks % TICKSPERSEC) * 100);
             }
 
-            while ((err = clock_nanosleep( CLOCK_REALTIME, TIMER_ABSTIME, &when, NULL )) == EINTR);
+            struct timespec remaining = nano_timeout;
+            err = TEMP_FAILURE_RETRY_CLOCK_NANOSLEEP(CLOCK_REALTIME, TIMER_ABSTIME, &nano_timeout, &remaining);
             if (!err)
                 return STATUS_SUCCESS;
             else
-                disable_clock_nanosleep = TRUE;
+                return errno_to_status( err );
         }
-#endif
+        else
+        {
+            NTSTATUS ret = NtYieldExecution();
+            return ret;
+        }
+#else
 
         if (when < 0)
         {
@@ -1913,6 +1935,7 @@ NTSTATUS WINAPI NtDelayExecution( BOOLEAN alertable, const LARGE_INTEGER *timeou
             tv.tv_usec = diff % 1000000;
             if (select( 0, NULL, NULL, NULL, &tv ) != -1) break;
         }
+#endif
     }
     return STATUS_SUCCESS;
 }
-- 
2.46.0

